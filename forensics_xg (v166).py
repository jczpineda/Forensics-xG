# -*- coding: utf-8 -*-
"""Forensics xG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HXahst9EouNaxkFii2bNbwgR_lbGrts5
"""

!pkill -f streamlit
!pkill -f localtunnel
!pkill -f cloudflared
import os
import glob
import shutil

# 1. RE-INSTALL MISSING LIBRARIES (The Fix)
!pip install mplsoccer plotly pandas streamlit matplotlib openpyxl -q

# 2. Clean up files
for f in glob.glob("cloudflared*"):
    try: os.remove(f)
    except: pass

if os.path.exists(".streamlit"):
    shutil.rmtree(".streamlit")

# 3. Download Cloudflare
!wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O cloudflared-linux-amd64
!chmod +x cloudflared-linux-amd64

print("‚úÖ Libraries restored. Forensic tools calibrated.")

!pkill -f streamlit
!pkill -f localtunnel
!pkill -f cloudflared
import os
import glob
import shutil

# 1. Clean up
for f in glob.glob("cloudflared*"):
    try: os.remove(f)
    except: pass

if os.path.exists(".streamlit"):
    shutil.rmtree(".streamlit")

# 2. Download Tunnel
!wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O cloudflared-linux-amd64
!chmod +x cloudflared-linux-amd64

# 3. Verify Libraries
!pip install mplsoccer plotly pandas streamlit matplotlib openpyxl scipy -q

print("‚úÖ Blueprint updated. v166.0 deploying.")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile forensics_app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import json
# import requests
# from mplsoccer import Pitch
# import plotly.express as px
# import matplotlib.patches as mpatches
# from scipy.spatial import ConvexHull
# from io import BytesIO
# from urllib.parse import quote
# import matplotlib.pyplot as plt
# import os
# 
# # --- 1. CONFIGURATION ---
# os.makedirs(".streamlit", exist_ok=True)
# with open(".streamlit/config.toml", "w") as f:
#     f.write("""
# [theme]
# base="dark"
# primaryColor="#ff4b4b"
# backgroundColor="#0e1117"
# secondaryBackgroundColor="#262730"
# textColor="#fafafa"
# font="sans serif"
# [server]
# headless = true
# """)
# 
# # --- 2. SETUP ---
# st.set_page_config(page_title="Forensics xG", layout="wide", page_icon="üß¨")
# 
# # --- 3. DATA LOADER ---
# GITHUB_BASE = "https://raw.githubusercontent.com/jczpineda/Forensics-xG/main/"
# 
# @st.cache_data(show_spinner=False)
# def load_stats_data(path_or_url):
#     if path_or_url.startswith("http"):
#         url = path_or_url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/")
#     else:
#         safe_path = quote(path_or_url)
#         url = GITHUB_BASE + safe_path
# 
#     try:
#         r = requests.get(url)
#         if r.status_code != 200: return None, f"HTTP {r.status_code}"
# 
#         if url.lower().endswith('.csv'): df = pd.read_csv(BytesIO(r.content))
#         else: df = pd.read_excel(BytesIO(r.content), engine='openpyxl')
# 
#         df.columns = df.columns.astype(str).str.strip()
#         for col in df.columns: df[col] = pd.to_numeric(df[col], errors='ignore')
#         return df, None
#     except Exception as e: return None, str(e)
# 
# @st.cache_data(show_spinner=False)
# def load_match_data(path_or_url):
#     if path_or_url.startswith("http"):
#         url = path_or_url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/")
#     else:
#         safe_path = quote(path_or_url)
#         url = GITHUB_BASE + safe_path
# 
#     try:
#         r = requests.get(url)
#         if r.status_code != 200: return None, f"HTTP {r.status_code}"
# 
#         text = r.content.decode('utf-8', errors='ignore')
#         s, e = text.find('('), text.rfind(')')
#         if s != -1 and e != -1: json_data = json.loads(text[s+1:e])
#         else:
#             s, e = text.find('{'), text.rfind('}')
#             if s != -1 and e != -1: json_data = json.loads(text[s:e+1])
#             else: return None, "Invalid JSON"
# 
#         events = []
#         try:
#             contestants = json_data['matchInfo']['contestant']
#             home_name, home_id = contestants[0]['name'], contestants[0]['id']
#             away_name = contestants[1]['name']
#             raw = json_data.get('liveData', {}).get('event', [])
# 
#             for i, ev in enumerate(raw):
#                 try:
#                     tid = int(ev.get('typeId', 0))
#                     qualifiers = ev.get('qualifier', [])
# 
#                     is_og = any(q['qualifierId'] == 28 for q in qualifiers)
#                     is_cross = any(q['qualifierId'] == 2 for q in qualifiers)
# 
#                     x_start = float(ev.get('x', 0))
#                     y_start = float(ev.get('y', 0))
#                     end_x = next((q['value'] for q in qualifiers if q['qualifierId']==140), x_start)
#                     end_y = next((q['value'] for q in qualifiers if q['qualifierId']==141), y_start)
# 
#                     outcome = "Successful" if ev.get('outcome')==1 else "Unsuccessful"
#                     if tid == 16 and is_og: outcome = "Own Goal"
# 
#                     team_name = home_name if ev.get('contestantId') == home_id else away_name
# 
#                     events.append({
#                         "Index": i,
#                         "Type": tid,
#                         "Player": ev.get('playerName', 'Unknown'),
#                         "Team": team_name,
#                         "Period": ev.get('periodId'),
#                         "x": x_start,
#                         "y": y_start,
#                         "endX": float(end_x),
#                         "endY": float(end_y),
#                         "Outcome": outcome,
#                         "Minute": int(ev.get('timeMin', 0)),
#                         "isCross": is_cross,
#                         "isHome": (team_name == home_name)
#                     })
#                 except: continue
#         except: return None, "Parse Error"
# 
#         return pd.DataFrame(events), None
#     except Exception as e: return None, str(e)
# 
# # --- 4. DATA INDEX ---
# CASE_DATABASE = {
#     "RUBEN AMORIM": {
#         "json_files": {
#             "vs Arsenal": "amorim.json/Arsenal.JSON",
#             "vs Aston Villa": "amorim.json/Aston Villa.JSON",
#             "vs Bournemouth": "amorim.json/Bournemouth.JSON",
#             "vs Brentford": "amorim.json/Brentford.JSON",
#             "vs Brighton": "amorim.json/Brighton.JSON",
#             "vs Burnley": "amorim.json/Burnley.JSON",
#             "vs Chelsea": "amorim.json/Chelsea.JSON",
#             "vs Crystal Palace": "amorim.json/Crystal Palace.JSON",
#             "vs Everton": "amorim.json/Everton.JSON",
#             "vs Fulham": "amorim.json/Fulham.JSON",
#             "vs Leeds United": "amorim.json/Leeds United.JSON",
#             "vs Liverpool": "amorim.json/Liverpool.JSON",
#             "vs Manchester City": "amorim.json/Manchester City.JSON",
#             "vs Newcastle United": "amorim.json/Newcastle United.JSON",
#             "vs Nottingham Forest": "amorim.json/Nottingham.JSON",
#             "vs Sunderland": "amorim.json/Sunderland.JSON",
#             "vs Tottenham": "amorim.json/Tottenham.JSON",
#             "vs West Ham": "amorim.json/West Ham.JSON",
#             "vs Wolverhampton": "amorim.json/Wolverhampton.JSON",
#             "vs Wolverhampton (2)": "amorim.json/Wolverhampton 2.JSON"
#         },
#         "stats_files": {
#             "üß§ GK Advanced (Against)": "amorim.csv/Advanced Goalkeeper Stats Against (2025-2026).xlsx",
#             "üß§ GK Advanced (For)": "amorim.csv/Advanced Goalkeeper Stats For (2025-2026).xlsx",
#             "üß§ GK Standard (Against)": "amorim.csv/Goalkeeper Stats Against (2025-2026).xlsx",
#             "üß§ GK Standard (For)": "amorim.csv/Goalkeeper Stats For (2025-2026).xlsx",
#             "üéØ Shooting (Against)": "amorim.csv/Shooting Against (2025-2026).xlsx",
#             "üéØ Shooting (For)": "amorim.csv/Shooting For (2025-2026).xlsx",
#             "‚ö° Goal/Shot Creation (Against)": "amorim.csv/Squad Goal and Shot Creation Against (2025-2026).xlsx",
#             "‚ö° Goal/Shot Creation (For)": "amorim.csv/Squad Goal and Shot Creation For (2025-2026).xlsx",
#             "‚öΩ Passing (Against)": "amorim.csv/Passing Against (2025-2026).xlsx",
#             "‚öΩ Passing (For)": "amorim.csv/Passing For (2025-2026).xlsx",
#             "üß† Passing Types (Against)": "amorim.csv/Passing Types Against (2025-2026).xlsx",
#             "üß† Passing Types (For)": "amorim.csv/Passing Types For (2025-2026).xlsx",
#             "‚è≥ Possession (Against)": "amorim.csv/Possession Against (2025-2026).xlsx",
#             "‚è≥ Possession (For)": "amorim.csv/Possession For (2025-2026).xlsx",
#             "üõ°Ô∏è Squad Defense (Against)": "amorim.csv/Squad Defense Against (2025-2026).xlsx",
#             "üõ°Ô∏è Squad Defense (For)": "amorim.csv/Squad Defense For (2025-2026).xlsx",
#             "üèÜ Overall Results": "amorim.csv/Overall Results (2025-2026).xlsx",
#             "üè† Home/Away Results": "amorim.csv/Home-Away Results (2025-2026).xlsx",
#             "‚è±Ô∏è Playing Time (Against)": "amorim.csv/Playing Time Against (2025-2026).xlsx",
#             "‚è±Ô∏è Playing Time (For)": "amorim.csv/Playing Time For (2025-2026).xlsx",
#             "üìä Standard Stats (Against)": "amorim.csv/Standard Stats Against (2025-2026).xlsx",
#             "üìä Standard Stats (For)": "amorim.csv/Standard Stats For (2025-2026).xlsx",
#             "üß© Misc Stats (Against)": "amorim.csv/Miscellaneous Stats Against (2025-2026).xlsx",
#             "üß© Misc Stats (For)": "amorim.csv/Miscellaneous Stats For (2025-2026).xlsx",
#         }
#     },
#     "DARREN FLETCHER": {
#         "json_files": { "vs Burnley (2)": "fletcher.json/Burnley 2.JSON" },
#         "stats_files": {}
#     },
#     "MICHAEL CARRICK": {
#         "json_files": { "vs Arsenal (2)": "carrick.json/Arsenal 2.JSON", "vs Manchester City (2)": "carrick.json/Manchester City 2.JSON" },
#         "stats_files": {}
#     }
# }
# 
# # --- 5. INTERFACE ---
# st.markdown("""
#     <style>
#     .tagline { font-size: 24px !important; font-weight: 700 !important; color: #a3a8b8 !important; margin-top: -20px !important; margin-bottom: 30px !important; }
#     header {visibility: hidden;}
#     [data-testid="stMetricValue"] { font-size: 26px !important; color: #ff4b4b !important; }
#     [data-testid="stMetricLabel"] { font-size: 16px !important; color: #a3a8b8 !important; }
#     </style>
# """, unsafe_allow_html=True)
# 
# c1, c2 = st.columns([1, 8])
# with c1: st.markdown("# üß¨")
# with c2:
#     st.title("FORENSICS xG | CRIME SCENE INVESTIGATION")
#     st.markdown('<div class="tagline">Where the Beautiful Game Meets Hard Evidence</div>', unsafe_allow_html=True)
# st.divider()
# 
# st.subheader("SELECT SUSPECT")
# 
# managers = list(CASE_DATABASE.keys())
# tabs = st.tabs(managers)
# 
# for i, manager in enumerate(managers):
#     with tabs[i]:
#         sub_t1, sub_t2 = st.tabs(["üìä STATISTICAL REPORTS", "‚öΩ MATCH TELEMETRY"])
# 
#         # === TAB A: STATS ===
#         with sub_t1:
#             files = CASE_DATABASE[manager]["stats_files"]
#             if files:
#                 options = list(files.keys())
#                 selected_option = st.selectbox("Select Evidence File", options, key=f"s_{manager}")
#                 target_path = files.get(selected_option, "")
# 
#                 if target_path:
#                     df, err = load_stats_data(target_path)
#                     if df is not None:
#                         has_90s = '90s' in df.columns
#                         c_toggle, _ = st.columns([2, 4])
#                         use_per_90 = c_toggle.toggle("‚öñÔ∏è Normalize Per 90", key=f"p90_{manager}") if has_90s else False
# 
#                         display_df = df.copy()
#                         if use_per_90:
#                             for col in display_df.select_dtypes(include=np.number).columns:
#                                 if col not in ['90s', 'Year', 'Age', 'Season']:
#                                     display_df[col] = (display_df[col] / display_df['90s']).round(2)
# 
#                         all_cols = display_df.columns.tolist()
#                         num_cols = display_df.select_dtypes(include=np.number).columns.tolist()
# 
#                         if all_cols:
#                             c1, c2, c3 = st.columns(3)
#                             x = c1.selectbox("X Axis", all_cols, index=0, key=f"sx_{manager}")
#                             y = c2.selectbox("Y Axis", num_cols if num_cols else all_cols, index=1 if len(num_cols)>1 else 0, key=f"sy_{manager}")
#                             lbl = c3.selectbox("Label", all_cols, index=0, key=f"sl_{manager}")
# 
#                             if y in num_cols:
#                                 fig = px.scatter(display_df, x=x, y=y, text=lbl, template="plotly_dark")
#                                 fig.update_traces(marker=dict(size=12, color='#ff4b4b', line=dict(width=1, color='white')), textposition='top center')
#                                 fig.update_layout(height=500, plot_bgcolor='#0e1117', paper_bgcolor='#0e1117')
#                                 st.plotly_chart(fig, use_container_width=True)
# 
#                             st.divider()
#                             st.dataframe(display_df, use_container_width=True)
#             else:
#                 st.info("No statistical reports available for this suspect. Please switch to the **MATCH TELEMETRY** tab.")
# 
#         # === TAB B: TELEMETRY ===
#         with sub_t2:
#             files = CASE_DATABASE[manager]["json_files"]
#             options = list(files.keys())
# 
#             if options:
#                 selected_match = st.selectbox("Select Match", options, key=f"m_{manager}")
#                 target_path = files.get(selected_match, "")
# 
#                 if target_path:
#                     with st.spinner("Analyzing Match Data..."):
#                         match_df, err = load_match_data(target_path)
# 
#                     if match_df is not None and not match_df.empty:
#                         # Identify Home/Away
#                         teams = match_df['Team'].unique()
# 
#                         st.header(f"{teams[0]} vs {teams[1]}")
# 
#                         c1, c2, c3 = st.columns(3)
#                         sel_team = c1.selectbox("Squad", teams, key=f"st_{manager}")
#                         team_players = sorted(match_df[match_df['Team']==sel_team]['Player'].unique())
#                         team_players.insert(0, "All Players")
#                         sel_player = c2.selectbox("Player", team_players, key=f"sp_{manager}")
#                         sel_period = c3.selectbox("Period", ["Full Match", "1st Half", "2nd Half"], key=f"sper_{manager}")
# 
#                         # BASIC FILTER
#                         plot_df = match_df[match_df['Team'] == sel_team]
#                         if sel_period == "1st Half": plot_df = plot_df[plot_df['Period'] == 1]
#                         elif sel_period == "2nd Half": plot_df = plot_df[plot_df['Period'] == 2]
#                         if sel_player != "All Players": plot_df = plot_df[plot_df['Player'] == sel_player]
# 
#                         # STATS
#                         opp_team = [t for t in teams if t != sel_team][0]
#                         opp_stats = match_df[match_df['Team'] == opp_team]
#                         if sel_period == "1st Half": opp_stats = opp_stats[opp_stats['Period'] == 1]
#                         elif sel_period == "2nd Half": opp_stats = opp_stats[opp_stats['Period'] == 2]
#                         opp_passes = len(opp_stats[opp_stats['Type'] == 1])
#                         my_def_actions = len(plot_df[plot_df['Type'].isin([4, 7, 8])])
#                         ppda = round(opp_passes / my_def_actions, 1) if my_def_actions > 0 else 0
# 
#                         full_match_f3 = match_df[(match_df['Type'] == 1) & (match_df['x'] > 66.6)]
#                         field_tilt = 0
#                         if not full_match_f3.empty:
#                             f3_counts = full_match_f3['Team'].value_counts()
#                             team_f3 = f3_counts.get(sel_team, 0)
#                             total_f3 = f3_counts.sum()
#                             field_tilt = round((team_f3 / total_f3 * 100), 1)
# 
#                         total_passes = len(plot_df[plot_df['Type'] == 1])
#                         succ_passes = len(plot_df[(plot_df['Type'] == 1) & (plot_df['Outcome'] == 'Successful')])
#                         pass_acc = round((succ_passes / total_passes * 100), 1) if total_passes > 0 else 0
#                         total_shots = len(plot_df[plot_df['Type'].isin([13, 14, 15, 16])])
#                         goals = len(plot_df[plot_df['Type'] == 16])
#                         tackles = len(plot_df[plot_df['Type'] == 7])
#                         total_def = tackles + len(plot_df[plot_df['Type'] == 8]) + len(plot_df[plot_df['Type'] == 12])
#                         fouls = len(plot_df[plot_df['Type'] == 4])
# 
#                         st.divider()
#                         m1, m2, m3, m4, m5, m6 = st.columns(6)
#                         m1.metric("‚öΩ Passing", f"{succ_passes}/{total_passes}", f"{pass_acc}%")
#                         m2.metric("üéØ Shooting", f"{goals} Goals", f"{total_shots} Shots")
#                         m3.metric("üõ°Ô∏è Def. Actions", f"{total_def}", f"{tackles} Tackles")
#                         m4.metric("‚ö†Ô∏è Discipline", f"{fouls} Fouls", "Committed")
#                         m5.metric("‚öñÔ∏è Field Tilt", f"{field_tilt}%", "Final 3rd Share")
#                         m6.metric("üõë PPDA", f"{ppda}", "Passes per Def. Action")
#                         st.divider()
# 
#                         # VISUALIZATION
#                         vis_options = ["The Architect (Build-Up Phase)", "Momentum Map", "Duel Map (Tackles Won/Lost)", "Game Control (Possession)", "Zone 14 & Half-Spaces", "Creator Map (Shot Assists)", "Passing Network (Structure)", "Pass Sonar (Radar)", "Impact Zone (Convex Hull)", "Attacking Zones (5 Lanes)", "Zone Invasions", "The Pulse (Shot Race)", "The Breakout (Progressive Carries)", "The Air Raid (Crossing Zones)", "Pass Map", "Shot Map (Ballistics)", "Defensive Actions", "Heatmap"]
#                         modules = st.multiselect("Evidence Layers", vis_options, default=["The Architect (Build-Up Phase)"], key=f"mod_{manager}")
# 
#                         # --- PREPARE VISUAL DATAFRAME (THE FLIP) ---
#                         viz_df = plot_df.copy()
#                         is_home_team = viz_df['isHome'].iloc[0] if not viz_df.empty else False
# 
#                         if not is_home_team:
#                             viz_df['x'] = 100 - viz_df['x']
#                             viz_df['y'] = 100 - viz_df['y']
#                             viz_df['endX'] = 100 - viz_df['endX']
#                             viz_df['endY'] = 100 - viz_df['endY']
#                             attack_label = "‚¨ÖÔ∏è Attacking Direction"
#                         else:
#                             attack_label = "Attacking Direction ‚û°Ô∏è"
# 
#                         # CHARTS
#                         if "Game Control (Possession)" in modules:
#                             st.subheader("üéÆ Game Control: Possession % (Rolling 5-min)")
#                             full = match_df.copy()
#                             full['MinBin'] = (full['Minute'] // 5) * 5
#                             poss_data = full[full['Type'] == 1].groupby(['MinBin', 'Team']).size().reset_index(name='Passes')
#                             poss_pivot = poss_data.pivot(index='MinBin', columns='Team', values='Passes').fillna(0)
#                             poss_pivot['Total'] = poss_pivot.sum(axis=1)
#                             if sel_team in poss_pivot.columns:
#                                 poss_pivot['Possession'] = (poss_pivot[sel_team] / poss_pivot['Total']) * 100
#                                 fig_gc = px.area(poss_pivot, x=poss_pivot.index, y='Possession', labels={'MinBin': 'Minute', 'Possession': f'{sel_team} Possession %'}, template="plotly_dark", color_discrete_sequence=['#ff4b4b'])
#                                 fig_gc.update_yaxes(range=[0, 100])
#                                 fig_gc.add_hline(y=50, line_dash="dash", line_color="white", opacity=0.5)
#                                 st.plotly_chart(fig_gc, use_container_width=True)
# 
#                         if "Momentum Map" in modules:
#                             st.subheader("üìà Momentum Gap: Home vs Away")
#                             mom_base = match_df.sort_values("Index").copy()
#                             if sel_period == "1st Half": mom_base = mom_base[mom_base['Period'] == 1]
#                             elif sel_period == "2nd Half": mom_base = mom_base[mom_base['Period'] == 2]
#                             mom_base['FinalThirdEntry'] = ((mom_base['Type'] == 1) & (mom_base['Outcome'] == 'Successful') & (mom_base['endX'] > 66.6)).astype(int)
#                             mom_base['CumulativeThreat'] = mom_base.groupby('Team')['FinalThirdEntry'].cumsum()
#                             fig_mom = px.line(mom_base, x='Index', y='CumulativeThreat', color='Team', labels={'Index': 'Match Progression', 'CumulativeThreat': 'Attacking Pressure'}, color_discrete_map={sel_team: '#ff4b4b'}, template="plotly_dark")
#                             opponent = [t for t in teams if t != sel_team][0]
#                             fig_mom.update_traces(selector=dict(name=opponent), line_color='grey')
#                             fig_mom.update_layout(paper_bgcolor='#0e1117', plot_bgcolor='#0e1117', legend_title_text='')
#                             st.plotly_chart(fig_mom, use_container_width=True)
# 
#                         if "The Pulse (Shot Race)" in modules:
#                             st.subheader("üìà The Pulse: Shot Accumulation Race")
#                             shot_race = match_df[match_df['Type'].isin([13, 14, 15, 16])].sort_values("Index").copy()
#                             if not shot_race.empty:
#                                 shot_race['Count'] = 1
#                                 shot_race['Cumulative Shots'] = shot_race.groupby('Team')['Count'].cumsum()
#                                 fig_pulse = px.line(shot_race, x='Minute', y='Cumulative Shots', color='Team', title='Shot Race (0-90 Mins)', labels={'Minute': 'Match Minute', 'Cumulative Shots': 'Total Shots Taken'}, line_shape='hv', color_discrete_map={sel_team: '#ff4b4b'}, template="plotly_dark")
#                                 opponent = [t for t in teams if t != sel_team][0]
#                                 fig_pulse.update_traces(selector=dict(name=opponent), line_color='grey')
#                                 fig_pulse.update_layout(paper_bgcolor='#0e1117', plot_bgcolor='#0e1117')
#                                 st.plotly_chart(fig_pulse, use_container_width=True)
#                             else: st.write("No shots recorded.")
# 
#                         # PITCH
#                         pitch_modules = [m for m in modules if m not in ["Momentum Map", "Game Control (Possession)", "Pass Sonar (Radar)", "The Pulse (Shot Race)"]]
# 
#                         if "Pass Sonar (Radar)" in modules and sel_player != "All Players":
#                             st.subheader(f"üì° Pass Sonar: {sel_player}")
#                             p_passes = plot_df[(plot_df['Type'] == 1) & (plot_df['Outcome'] == 'Successful')]
#                             if not p_passes.empty:
#                                 dx = p_passes['endX'] - p_passes['x']
#                                 dy = p_passes['endY'] - p_passes['y']
#                                 angles = np.arctan2(dy, dx)
#                                 fig_polar = plt.figure(figsize=(6, 6))
#                                 fig_polar.set_facecolor('#0e1117')
#                                 ax_polar = fig_polar.add_subplot(111, polar=True)
#                                 ax_polar.set_facecolor('#0e1117')
#                                 ax_polar.hist(angles, bins=24, color='#ff4b4b', alpha=0.7, edgecolor='white')
#                                 ax_polar.set_theta_zero_location('E')
#                                 ax_polar.set_yticks([])
#                                 ax_polar.grid(color='#262730')
#                                 ax_polar.tick_params(axis='x', colors='white')
#                                 st.pyplot(fig_polar)
#                                 plt.close(fig_polar)
# 
#                         if pitch_modules:
#                             st.markdown(f"<h3 style='text-align: center; color: white;'>{attack_label}</h3>", unsafe_allow_html=True)
#                             fig, ax = plt.subplots(figsize=(10, 7))
#                             fig.set_facecolor('#0e1117')
#                             ax.set_facecolor('#0e1117')
#                             pitch = Pitch(pitch_type='opta', pitch_color='#0e1117', line_color='white')
#                             pitch.draw(ax=ax)
# 
#                             # --- 5. THE ARCHITECT (BUILD-UP PHASE) [WITH COUNTS] ---
#                             if "The Architect (Build-Up Phase)" in pitch_modules:
#                                 build_up_indices = plot_df[(plot_df['Type'] == 1) & (plot_df['x'] < 33)].index
#                                 build_up_viz = viz_df.loc[build_up_indices]
# 
#                                 if not build_up_viz.empty:
#                                     build_up_viz['norm_endX'] = plot_df.loc[build_up_indices, 'endX']
# 
#                                     circ = build_up_viz[build_up_viz['norm_endX'] < 33]
#                                     prog = build_up_viz[(build_up_viz['norm_endX'] >= 33) & (build_up_viz['norm_endX'] < 66)]
#                                     launch = build_up_viz[build_up_viz['norm_endX'] >= 66]
# 
#                                     pitch.lines(circ.x, circ.y, circ.endX, circ.endY, color='white', alpha=0.1, lw=2, ax=ax, label=f'Circulation: {len(circ)}')
#                                     pitch.lines(prog.x, prog.y, prog.endX, prog.endY, color='#00ffff', alpha=0.6, lw=3, ax=ax, label=f'Progression: {len(prog)}')
#                                     pitch.scatter(prog.endX, prog.endY, s=30, c='#00ffff', ax=ax)
#                                     pitch.lines(launch.x, launch.y, launch.endX, launch.endY, color='#ff00ff', alpha=0.8, lw=3, ax=ax, label=f'Long Ball: {len(launch)}')
#                                     pitch.scatter(launch.endX, launch.endY, s=30, c='#ff00ff', ax=ax)
# 
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Zone 14 & Half-Spaces" in pitch_modules:
#                                 actions = plot_df[plot_df['Outcome'] == 'Successful']
#                                 def get_zone_counts(df, x_min, x_max, y_min, y_max):
#                                     ev = df[(df['x'] >= x_min) & (df['x'] <= x_max) & (df['y'] >= y_min) & (df['y'] <= y_max)]
#                                     return len(ev[ev['Type'] == 1]), len(ev[ev['Type'] == 3])
# 
#                                 p_z14, d_z14 = get_zone_counts(actions, 65, 85, 37, 63)
#                                 p_lhs, d_lhs = get_zone_counts(actions, 65, 85, 20, 37)
#                                 p_rhs, d_rhs = get_zone_counts(actions, 65, 85, 63, 80)
# 
#                                 # Flip drawing coords if Away
#                                 z14_x, lhs_x, rhs_x = 65, 65, 65
#                                 if not is_home_team: z14_x, lhs_x, rhs_x = 15, 15, 15
# 
#                                 r_z14 = mpatches.Rectangle((z14_x, 37), 20, 26, alpha=0.4, color='#ffd700', ec='white')
#                                 ax.add_patch(r_z14)
#                                 ax.text(z14_x+10, 50, f"Zone 14\nP:{p_z14} | D:{d_z14}", color='white', ha='center', va='center', fontweight='bold', fontsize=10)
# 
#                                 r_lhs = mpatches.Rectangle((lhs_x, 20), 20, 17, alpha=0.3, color='#ff4b4b', ec='white')
#                                 ax.add_patch(r_lhs)
#                                 ax.text(lhs_x+10, 28.5, f"LHS\nP:{p_lhs} | D:{d_lhs}", color='white', ha='center', va='center', fontweight='bold', fontsize=9)
# 
#                                 r_rhs = mpatches.Rectangle((rhs_x, 63), 20, 17, alpha=0.3, color='#ff4b4b', ec='white')
#                                 ax.add_patch(r_rhs)
#                                 ax.text(rhs_x+10, 71.5, f"RHS\nP:{p_rhs} | D:{d_rhs}", color='white', ha='center', va='center', fontweight='bold', fontsize=9)
# 
#                             if "Attacking Zones (5 Lanes)" in pitch_modules:
#                                 f3_acts = plot_df[(plot_df['x'] > 66.6) & (plot_df['Type'] == 1) & (plot_df['Outcome'] == 'Successful')]
#                                 total = len(f3_acts)
#                                 if total > 0:
#                                     c_bottom = len(f3_acts[f3_acts['y'] <= 20])
#                                     c_lower = len(f3_acts[(f3_acts['y'] > 20) & (f3_acts['y'] <= 37)])
#                                     c_center = len(f3_acts[(f3_acts['y'] > 37) & (f3_acts['y'] <= 63)])
#                                     c_upper = len(f3_acts[(f3_acts['y'] > 63) & (f3_acts['y'] <= 80)])
#                                     c_top = len(f3_acts[f3_acts['y'] > 80])
# 
#                                     if is_home_team:
#                                         lane_labels = ["Right Flank", "Right Half", "Center", "Left Half", "Left Flank"]
#                                         lane_counts = [c_bottom, c_lower, c_center, c_upper, c_top]
#                                     else:
#                                         lane_labels = ["Left Flank", "Left Half", "Center", "Right Half", "Right Flank"]
#                                         lane_counts = [c_bottom, c_lower, c_center, c_upper, c_top]
# 
#                                     start_x = 66.6 if is_home_team else 0
#                                     y_starts = [0, 20, 37, 63, 80]
#                                     widths = [20, 17, 26, 17, 20]
# 
#                                     for i in range(5):
#                                         pct = (lane_counts[i] / total) * 100
#                                         rect = mpatches.Rectangle((start_x, y_starts[i]), 33.4, widths[i], alpha=min(0.9, max(0.2, pct/40)), color='#ff4b4b', ec='white')
#                                         ax.add_patch(rect)
#                                         ax.text(start_x+16.7, y_starts[i]+(widths[i]/2), f"{lane_labels[i]}\n{pct:.1f}%", color='white', ha='center', va='center', fontweight='bold', fontsize=9)
# 
#                             if "The Breakout (Progressive Carries)" in pitch_modules:
#                                 prog_indices = plot_df[plot_df['endX'] > plot_df['x'] + 10].index
#                                 carries_viz = viz_df.loc[prog_indices]
#                                 if not carries_viz.empty:
#                                     pitch.lines(carries_viz.x, carries_viz.y, carries_viz.endX, carries_viz.endY, lw=3, linestyle='dashed', color='#00ffff', alpha=0.8, ax=ax, label='Prog. Carry (>10m)')
#                                     pitch.scatter(carries_viz.x, carries_viz.y, s=50, c='#00ffff', ax=ax)
#                                     ax.legend(facecolor='#262730', labelcolor='white', title=f"Count: {len(carries_viz)}")
# 
#                             if "The Air Raid (Crossing Zones)" in pitch_modules:
#                                 crosses = viz_df[(viz_df['Type'] == 1) & (viz_df['isCross'] == True)]
#                                 if not crosses.empty:
#                                     succ = crosses[crosses['Outcome'] == 'Successful']
#                                     fail = crosses[crosses['Outcome'] == 'Unsuccessful']
#                                     pitch.arrows(succ.x, succ.y, succ.endX, succ.endY, width=2, color='#00ff85', label='Succ. Cross', ax=ax)
#                                     pitch.arrows(fail.x, fail.y, fail.endX, fail.endY, width=2, color='#ff4b4b', alpha=0.5, label='Failed Cross', ax=ax)
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Duel Map (Tackles Won/Lost)" in pitch_modules:
#                                 duels = viz_df[viz_df['Type'] == 7]
#                                 if not duels.empty:
#                                     won = duels[duels['Outcome'] == 'Successful']
#                                     lost = duels[duels['Outcome'] == 'Unsuccessful']
#                                     pitch.scatter(won.x, won.y, s=200, marker='p', c='#00ff85', edgecolors='black', ax=ax, label='Tackle Won')
#                                     pitch.scatter(lost.x, lost.y, s=200, marker='X', c='#ff4b4b', edgecolors='white', ax=ax, label='Tackle Lost')
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Passing Network (Structure)" in pitch_modules:
#                                 if "Passing Network (Structure)" in modules:
#                                     min_slider = st.slider("Match Minutes Window", 0, 100, (0, 90), key=f"nw_slider_{manager}")
#                                 net_df = viz_df.copy()
#                                 net_df = net_df[(net_df['Minute'] >= min_slider[0]) & (net_df['Minute'] <= min_slider[1])]
#                                 avg_pos = net_df.groupby('Player')[['x', 'y']].mean()
#                                 pass_counts = net_df.groupby('Player').size()
#                                 net_df['NextPlayer'] = net_df['Player'].shift(-1)
#                                 net_df['NextTeam'] = net_df['Team'].shift(-1)
#                                 connections = net_df[(net_df['Type'] == 1) & (net_df['Outcome'] == 'Successful') & (net_df['NextTeam'] == sel_team)]
#                                 if not connections.empty:
#                                     edges = connections.groupby(['Player', 'NextPlayer']).size().reset_index(name='count')
#                                     edges = edges[edges['count'] > 2]
#                                     for _, row in edges.iterrows():
#                                         p1, p2 = row['Player'], row['NextPlayer']
#                                         if p1 in avg_pos.index and p2 in avg_pos.index:
#                                             width = row['count'] * 0.5
#                                             pitch.lines(avg_pos.loc[p1].x, avg_pos.loc[p1].y, avg_pos.loc[p2].x, avg_pos.loc[p2].y, lw=width, color='#ff4b4b', alpha=0.6, ax=ax, zorder=1)
#                                     pitch.scatter(avg_pos.x, avg_pos.y, s=pass_counts*5, color='#0e1117', edgecolors='white', linewidth=2, ax=ax, zorder=2)
#                                     for player, row in avg_pos.iterrows():
#                                         pitch.annotate(player.split(" ")[-1], xy=(row.x, row.y), c='white', va='center', ha='center', size=8, ax=ax, zorder=3)
# 
#                             if "Impact Zone (Convex Hull)" in pitch_modules:
#                                 def_pts = viz_df[viz_df['Type'].isin([4, 7, 8, 12])][['x', 'y']]
#                                 if len(def_pts) >= 3:
#                                     hull = ConvexHull(def_pts[['x', 'y']].values)
#                                     hull_pts = def_pts[['x', 'y']].values[hull.vertices]
#                                     hull_pts = np.vstack((hull_pts, hull_pts[0]))
#                                     poly = mpatches.Polygon(hull_pts, closed=True, facecolor='#ff4b4b', alpha=0.3, edgecolor='white', lw=2)
#                                     ax.add_patch(poly)
#                                     pitch.scatter(def_pts.x, def_pts.y, s=50, c='#ff4b4b', ax=ax, alpha=0.6)
# 
#                             if "Pass Map" in pitch_modules:
#                                 passes = viz_df[viz_df['Type'] == 1]
#                                 if not passes.empty:
#                                     succ = passes[passes['Outcome'] == 'Successful']
#                                     fail = passes[passes['Outcome'] == 'Unsuccessful']
#                                     pitch.arrows(succ.x, succ.y, succ.endX, succ.endY, width=2, color='#00ff85', alpha=0.3, ax=ax)
#                                     pitch.arrows(fail.x, fail.y, fail.endX, fail.endY, width=2, color='#ff4b4b', alpha=0.3, ax=ax)
# 
#                             if "Zone Invasions" in pitch_modules:
#                                 passes = viz_df[(viz_df['Type'] == 1) & (viz_df['Outcome'] == 'Successful')]
#                                 dribbles_won = viz_df[(viz_df['Type'] == 3) & (viz_df['Outcome'] == 'Successful')]
# 
#                                 if is_home_team:
#                                     f3_pass = passes[(passes['endX'] > 66) & (passes['endX'] <= 83)]
#                                     box_pass = passes[passes['endX'] > 83]
#                                     drib_won = dribbles_won[dribbles_won['x'] > 66]
#                                 else:
#                                     f3_pass = passes[(passes['endX'] < 33) & (passes['endX'] >= 17)]
#                                     box_pass = passes[passes['endX'] < 17]
#                                     drib_won = dribbles_won[dribbles_won['x'] < 33]
# 
#                                 if not f3_pass.empty:
#                                     pitch.arrows(f3_pass.x, f3_pass.y, f3_pass.endX, f3_pass.endY, width=3, color='white', alpha=0.6, ax=ax, label='Into F3')
#                                 if not box_pass.empty:
#                                     pitch.arrows(box_pass.x, box_pass.y, box_pass.endX, box_pass.endY, width=3, color='#ffd700', alpha=0.9, ax=ax, label='Into Box')
#                                 if not drib_won.empty:
#                                     pitch.scatter(drib_won.x, drib_won.y, s=150, marker='d', c='#00ffff', edgecolors='white', ax=ax, label='Succ. Dribble')
#                                 ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Shot Map (Ballistics)" in pitch_modules:
#                                 shots = viz_df[viz_df['Type'].isin([13, 14, 15, 16])]
#                                 if not shots.empty:
#                                     goals = shots[(shots['Type'] == 16) & (shots['Outcome'] != 'Own Goal')]
#                                     saved = shots[shots['Type'].isin([14, 15])]
#                                     missed = shots[shots['Type'] == 13]
#                                     pitch.scatter(goals.x, goals.y, s=400, marker='*', c='#00ff85', edgecolors='white', ax=ax, label='Goal')
#                                     pitch.scatter(saved.x, saved.y, s=200, marker='o', c='#ffd700', edgecolors='black', ax=ax, label='Saved/Post')
#                                     pitch.scatter(missed.x, missed.y, s=200, marker='x', c='#ff4b4b', ax=ax, label='Miss')
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Defensive Actions" in pitch_modules:
#                                 def_act = viz_df[viz_df['Type'].isin([4, 7, 8, 12])]
#                                 if not def_act.empty:
#                                     t = def_act[def_act['Type'] == 7]
#                                     i = def_act[def_act['Type'] == 8]
#                                     f = def_act[def_act['Type'] == 4]
#                                     pitch.scatter(t.x, t.y, s=150, marker='d', c='#3399ff', edgecolors='white', ax=ax, label='Tackle')
#                                     pitch.scatter(i.x, i.y, s=150, marker='s', c='#ff9900', edgecolors='black', ax=ax, label='Interception')
#                                     pitch.scatter(f.x, f.y, s=150, marker='X', c='#ff4b4b', ax=ax, label='Foul')
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Heatmap" in pitch_modules and not viz_df.empty:
#                                 pitch.kdeplot(viz_df.x, viz_df.y, ax=ax, cmap='hot', fill=True, levels=100, alpha=0.6)
# 
#                             st.pyplot(fig)
#                             plt.close(fig)
#                     else: st.error(f"Error: {err}")

!streamlit run forensics_app.py &>/dev/null &
!./cloudflared-linux-amd64 tunnel --url http://localhost:8501