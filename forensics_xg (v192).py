# -*- coding: utf-8 -*-
"""Forensics xG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HXahst9EouNaxkFii2bNbwgR_lbGrts5
"""

!pkill -f streamlit
!pkill -f localtunnel
!pkill -f cloudflared
import os
import glob
import shutil

# 1. Clean up
for f in glob.glob("cloudflared*"):
    try: os.remove(f)
    except: pass

if os.path.exists(".streamlit"):
    shutil.rmtree(".streamlit")

# 2. Download Tunnel
!wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O cloudflared-linux-amd64
!chmod +x cloudflared-linux-amd64

# 3. Verify Libraries
!pip install mplsoccer plotly pandas streamlit matplotlib openpyxl scipy -q

print("‚úÖ Settings menu unmasked. v190.0 deploying.")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile forensics_app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import json
# import requests
# from mplsoccer import Pitch
# import plotly.express as px
# import matplotlib.patches as mpatches
# import matplotlib.lines as mlines
# from scipy.spatial import ConvexHull
# from io import BytesIO
# from urllib.parse import quote
# import matplotlib.pyplot as plt
# import os
# 
# # --- 1. CONFIGURATION ---
# os.makedirs(".streamlit", exist_ok=True)
# with open(".streamlit/config.toml", "w") as f:
#     f.write("""
# [theme]
# base="dark"
# primaryColor="#ff4b4b"
# backgroundColor="#0e1117"
# secondaryBackgroundColor="#262730"
# textColor="#fafafa"
# font="sans serif"
# [server]
# headless = true
# """)
# 
# # --- 2. SETUP ---
# st.set_page_config(page_title="Forensics xG", layout="wide", page_icon="üß¨")
# 
# # --- 3. DATA LOADER ---
# GITHUB_BASE = "https://raw.githubusercontent.com/jczpineda/Forensics-xG/main/"
# 
# @st.cache_data(show_spinner=False)
# def load_stats_data(path_or_url):
#     if path_or_url.startswith("http"):
#         url = path_or_url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/")
#     else:
#         safe_path = quote(path_or_url)
#         url = GITHUB_BASE + safe_path
# 
#     try:
#         r = requests.get(url)
#         if r.status_code != 200: return None, f"HTTP {r.status_code}"
# 
#         if url.lower().endswith('.csv'): df = pd.read_csv(BytesIO(r.content))
#         else: df = pd.read_excel(BytesIO(r.content), engine='openpyxl')
# 
#         df.columns = df.columns.astype(str).str.strip()
#         for col in df.columns: df[col] = pd.to_numeric(df[col], errors='ignore')
#         return df, None
#     except Exception as e: return None, str(e)
# 
# @st.cache_data(show_spinner=False)
# def load_match_data(path_or_url):
#     if path_or_url.startswith("http"):
#         url = path_or_url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/")
#     else:
#         safe_path = quote(path_or_url)
#         url = GITHUB_BASE + safe_path
# 
#     try:
#         r = requests.get(url)
#         if r.status_code != 200: return None, f"HTTP {r.status_code}"
# 
#         text = r.content.decode('utf-8', errors='ignore')
#         s, e = text.find('('), text.rfind(')')
#         if s != -1 and e != -1: json_data = json.loads(text[s+1:e])
#         else:
#             s, e = text.find('{'), text.rfind('}')
#             if s != -1 and e != -1: json_data = json.loads(text[s:e+1])
#             else: return None, "Invalid JSON"
# 
#         events = []
#         try:
#             contestants = json_data['matchInfo']['contestant']
#             home_name, home_id = contestants[0]['name'], contestants[0]['id']
#             away_name = contestants[1]['name']
#             raw = json_data.get('liveData', {}).get('event', [])
# 
#             for i, ev in enumerate(raw):
#                 try:
#                     tid = int(ev.get('typeId', 0))
#                     qualifiers = ev.get('qualifier', [])
# 
#                     is_og = any(q['qualifierId'] == 28 for q in qualifiers)
#                     is_cross = any(q['qualifierId'] == 2 for q in qualifiers)
#                     is_corner = any(q['qualifierId'] == 6 for q in qualifiers)
#                     is_fast_break = any(q['qualifierId'] in [23, 24] for q in qualifiers)
#                     is_blocked = any(q['qualifierId'] == 82 for q in qualifiers)
# 
#                     x_start = float(ev.get('x', 0))
#                     y_start = float(ev.get('y', 0))
#                     end_x = next((q['value'] for q in qualifiers if q['qualifierId']==140), x_start)
#                     end_y = next((q['value'] for q in qualifiers if q['qualifierId']==141), y_start)
# 
#                     outcome = "Successful" if ev.get('outcome')==1 else "Unsuccessful"
#                     if tid == 16 and is_og: outcome = "Own Goal"
# 
#                     team_name = home_name if ev.get('contestantId') == home_id else away_name
# 
#                     events.append({
#                         "Index": i,
#                         "Type": tid,
#                         "Player": ev.get('playerName', 'Unknown'),
#                         "Team": team_name,
#                         "Period": ev.get('periodId'),
#                         "x": x_start,
#                         "y": y_start,
#                         "endX": float(end_x),
#                         "endY": float(end_y),
#                         "Outcome": outcome,
#                         "Minute": int(ev.get('timeMin', 0)),
#                         "isCross": is_cross,
#                         "isCorner": is_corner,
#                         "isFastBreak": is_fast_break,
#                         "isBlocked": is_blocked,
#                         "isHome": (team_name == home_name)
#                     })
#                 except: continue
#         except: return None, "Parse Error"
# 
#         return pd.DataFrame(events), None
#     except Exception as e: return None, str(e)
# 
# # --- 4. DATA INDEX ---
# CASE_DATABASE = {
#     "RUBEN AMORIM": {
#         "json_files": {
#             "vs Arsenal": "amorim.json/Arsenal.JSON",
#             "vs Aston Villa": "amorim.json/Aston Villa.JSON",
#             "vs Bournemouth": "amorim.json/Bournemouth.JSON",
#             "vs Brentford": "amorim.json/Brentford.JSON",
#             "vs Brighton": "amorim.json/Brighton.JSON",
#             "vs Burnley": "amorim.json/Burnley.JSON",
#             "vs Chelsea": "amorim.json/Chelsea.JSON",
#             "vs Crystal Palace": "amorim.json/Crystal Palace.JSON",
#             "vs Everton": "amorim.json/Everton.JSON",
#             "vs Fulham": "amorim.json/Fulham.JSON",
#             "vs Leeds United": "amorim.json/Leeds United.JSON",
#             "vs Liverpool": "amorim.json/Liverpool.JSON",
#             "vs Manchester City": "amorim.json/Manchester City.JSON",
#             "vs Newcastle United": "amorim.json/Newcastle United.JSON",
#             "vs Nottingham Forest": "amorim.json/Nottingham.JSON",
#             "vs Sunderland": "amorim.json/Sunderland.JSON",
#             "vs Tottenham": "amorim.json/Tottenham.JSON",
#             "vs West Ham": "amorim.json/West Ham.JSON",
#             "vs Wolverhampton": "amorim.json/Wolverhampton.JSON",
#             "vs Wolverhampton (2)": "amorim.json/Wolverhampton 2.JSON"
#         },
#         "stats_files": {
#             "üß§ GK Advanced (Against)": "amorim.csv/Advanced Goalkeeper Stats Against (2025-2026).xlsx",
#             "üß§ GK Advanced (For)": "amorim.csv/Advanced Goalkeeper Stats For (2025-2026).xlsx",
#             "üß§ GK Standard (Against)": "amorim.csv/Goalkeeper Stats Against (2025-2026).xlsx",
#             "üß§ GK Standard (For)": "amorim.csv/Goalkeeper Stats For (2025-2026).xlsx",
#             "üéØ Shooting (Against)": "amorim.csv/Shooting Against (2025-2026).xlsx",
#             "üéØ Shooting (For)": "amorim.csv/Shooting For (2025-2026).xlsx",
#             "‚ö° Goal/Shot Creation (Against)": "amorim.csv/Squad Goal and Shot Creation Against (2025-2026).xlsx",
#             "‚ö° Goal/Shot Creation (For)": "amorim.csv/Squad Goal and Shot Creation For (2025-2026).xlsx",
#             "‚öΩ Passing (Against)": "amorim.csv/Passing Against (2025-2026).xlsx",
#             "‚öΩ Passing (For)": "amorim.csv/Passing For (2025-2026).xlsx",
#             "üß† Passing Types (Against)": "amorim.csv/Passing Types Against (2025-2026).xlsx",
#             "üß† Passing Types (For)": "amorim.csv/Passing Types For (2025-2026).xlsx",
#             "‚è≥ Possession (Against)": "amorim.csv/Possession Against (2025-2026).xlsx",
#             "‚è≥ Possession (For)": "amorim.csv/Possession For (2025-2026).xlsx",
#             "üõ°Ô∏è Squad Defense (Against)": "amorim.csv/Squad Defense Against (2025-2026).xlsx",
#             "üõ°Ô∏è Squad Defense (For)": "amorim.csv/Squad Defense For (2025-2026).xlsx",
#             "üèÜ Overall Results": "amorim.csv/Overall Results (2025-2026).xlsx",
#             "üè† Home/Away Results": "amorim.csv/Home-Away Results (2025-2026).xlsx",
#             "‚è±Ô∏è Playing Time (Against)": "amorim.csv/Playing Time Against (2025-2026).xlsx",
#             "‚è±Ô∏è Playing Time (For)": "amorim.csv/Playing Time For (2025-2026).xlsx",
#             "üìä Standard Stats (Against)": "amorim.csv/Standard Stats Against (2025-2026).xlsx",
#             "üìä Standard Stats (For)": "amorim.csv/Standard Stats For (2025-2026).xlsx",
#             "üß© Misc Stats (Against)": "amorim.csv/Miscellaneous Stats Against (2025-2026).xlsx",
#             "üß© Misc Stats (For)": "amorim.csv/Miscellaneous Stats For (2025-2026).xlsx",
#         }
#     },
#     "DARREN FLETCHER": {
#         "json_files": { "vs Burnley (2)": "fletcher.json/Burnley 2.JSON" },
#         "stats_files": {}
#     },
#     "MICHAEL CARRICK": {
#         "json_files": {
#             "vs Arsenal (2)": "carrick.json/Arsenal 2.JSON",
#             "vs Manchester City (2)": "carrick.json/Manchester City 2.JSON",
#             "vs Fulham (2)": "carrick.json/Fulham 2.JSON",
#             "vs Tottenham (2)": "carrick.json/Tottenham 2.JSON",
#             "vs West Ham (2)": "carrick.json/West Ham 2.JSON",
#             "vs Everton (2)": "carrick.json/Everton 2.JSON"
#         },
#         "stats_files": {}
#     }
# }
# 
# # --- 5. INTERFACE ---
# st.markdown("""
#     <style>
#     .tagline { font-size: 24px !important; font-weight: 700 !important; color: #a3a8b8 !important; margin-top: -20px !important; margin-bottom: 30px !important; }
#     [data-testid="stMetricValue"] { font-size: 24px !important; color: #ff4b4b !important; }
#     [data-testid="stMetricLabel"] { font-size: 14px !important; color: #a3a8b8 !important; }
#     </style>
# """, unsafe_allow_html=True)
# 
# c1, c2 = st.columns([1, 8])
# with c1: st.markdown("# üß¨")
# with c2:
#     st.title("FORENSICS xG | CRIME SCENE INVESTIGATION")
#     st.markdown('<div class="tagline">Where the Beautiful Game Meets Hard Evidence</div>', unsafe_allow_html=True)
# st.divider()
# 
# st.subheader("SELECT SUSPECT")
# 
# managers = list(CASE_DATABASE.keys())
# tabs = st.tabs(managers)
# 
# for i, manager in enumerate(managers):
#     with tabs[i]:
#         sub_t1, sub_t2, sub_t3 = st.tabs(["üìä STATISTICAL REPORTS", "‚öΩ MATCH TELEMETRY", "üë§ PLAYER PROFILE"])
# 
#         # === TAB A: STATS ===
#         with sub_t1:
#             files = CASE_DATABASE[manager]["stats_files"]
#             if files:
#                 options = list(files.keys())
#                 selected_option = st.selectbox("Select Evidence File", options, key=f"s_{manager}")
#                 target_path = files.get(selected_option, "")
# 
#                 if target_path:
#                     df, err = load_stats_data(target_path)
#                     if df is not None:
#                         has_90s = '90s' in df.columns
#                         c_toggle, _ = st.columns([2, 4])
#                         use_per_90 = c_toggle.toggle("‚öñÔ∏è Normalize Per 90", key=f"p90_{manager}") if has_90s else False
# 
#                         display_df = df.copy()
#                         if use_per_90:
#                             for col in display_df.select_dtypes(include=np.number).columns:
#                                 if col not in ['90s', 'Year', 'Age', 'Season']:
#                                     display_df[col] = (display_df[col] / display_df['90s']).round(2)
# 
#                         all_cols = display_df.columns.tolist()
#                         num_cols = display_df.select_dtypes(include=np.number).columns.tolist()
# 
#                         if all_cols:
#                             c1, c2, c3 = st.columns(3)
#                             x = c1.selectbox("X Axis", all_cols, index=0, key=f"sx_{manager}")
#                             y = c2.selectbox("Y Axis", num_cols if num_cols else all_cols, index=1 if len(num_cols)>1 else 0, key=f"sy_{manager}")
#                             lbl = c3.selectbox("Label", all_cols, index=0, key=f"sl_{manager}")
# 
#                             if y in num_cols:
#                                 fig = px.scatter(display_df, x=x, y=y, text=lbl, template="plotly_dark")
#                                 fig.update_traces(marker=dict(size=12, color='#ff4b4b', line=dict(width=1, color='white')), textposition='top center')
#                                 fig.update_layout(height=500, plot_bgcolor='#0e1117', paper_bgcolor='#0e1117')
#                                 st.plotly_chart(fig, use_container_width=True)
# 
#                             st.divider()
#                             st.dataframe(display_df, use_container_width=True)
#             else:
#                 st.info("No statistical reports available for this suspect. Please switch to the **MATCH TELEMETRY** tab.")
# 
#         # === TAB B: TELEMETRY ===
#         with sub_t2:
#             files = CASE_DATABASE[manager]["json_files"]
#             options = list(files.keys())
# 
#             if options:
#                 selected_match = st.selectbox("Select Match", options, key=f"m_{manager}")
#                 target_path = files.get(selected_match, "")
# 
#                 if target_path:
#                     with st.spinner("Analyzing Match Data..."):
#                         match_df, err = load_match_data(target_path)
# 
#                     if match_df is not None and not match_df.empty:
#                         home_team_rows = match_df[match_df['isHome'] == True]
#                         away_team_rows = match_df[match_df['isHome'] == False]
#                         home_name = home_team_rows['Team'].iloc[0] if not home_team_rows.empty else "Unknown Home"
#                         away_name = away_team_rows['Team'].iloc[0] if not away_team_rows.empty else "Unknown Away"
# 
#                         st.header(f"{home_name} vs {away_name}")
# 
#                         teams = match_df['Team'].unique()
#                         c1, c2, c3 = st.columns(3)
#                         sel_team = c1.selectbox("Squad", teams, key=f"st_{manager}")
# 
#                         team_players = sorted(match_df[match_df['Team']==sel_team]['Player'].unique())
#                         team_players.insert(0, "All Players")
#                         sel_player = c2.selectbox("Player", team_players, key=f"sp_{manager}")
# 
#                         # --- MINUTE SLIDER FOR MATCH TELEMETRY ---
#                         max_minute = int(match_df['Minute'].max()) if not match_df.empty else 95
#                         min_range = c3.slider("Minute Range", 0, max_minute, (0, max_minute), key=f"sper_{manager}")
# 
#                         # Global Data Filtering
#                         plot_df = match_df[match_df['Team'] == sel_team]
#                         plot_df = plot_df[(plot_df['Minute'] >= min_range[0]) & (plot_df['Minute'] <= min_range[1])]
# 
#                         if sel_player != "All Players":
#                             plot_df = plot_df[plot_df['Player'] == sel_player]
# 
#                         opp_team = [t for t in teams if t != sel_team][0]
#                         opp_stats = match_df[match_df['Team'] == opp_team]
#                         opp_stats = opp_stats[(opp_stats['Minute'] >= min_range[0]) & (opp_stats['Minute'] <= min_range[1])]
# 
#                         # Metrics Calculation
#                         opp_passes = len(opp_stats[opp_stats['Type'] == 1])
#                         my_def_actions = len(plot_df[plot_df['Type'].isin([4, 7, 8])])
#                         ppda = round(opp_passes / my_def_actions, 1) if my_def_actions > 0 else 0
# 
#                         full_match_f3 = match_df[(match_df['Type'] == 1) & (match_df['x'] > 66.6) &
#                                                (match_df['Minute'] >= min_range[0]) & (match_df['Minute'] <= min_range[1])]
#                         field_tilt = 0
#                         if not full_match_f3.empty:
#                             f3_counts = full_match_f3['Team'].value_counts()
#                             team_f3 = f3_counts.get(sel_team, 0)
#                             total_f3 = f3_counts.sum()
#                             field_tilt = round((team_f3 / total_f3 * 100), 1)
# 
#                         total_passes = len(plot_df[plot_df['Type'] == 1])
#                         succ_passes = len(plot_df[(plot_df['Type'] == 1) & (plot_df['Outcome'] == 'Successful')])
#                         pass_acc = round((succ_passes / total_passes * 100), 1) if total_passes > 0 else 0
#                         total_shots = len(plot_df[plot_df['Type'].isin([13, 14, 15, 16])])
#                         goals = len(plot_df[plot_df['Type'] == 16])
#                         tackles = len(plot_df[plot_df['Type'] == 7])
#                         total_def = tackles + len(plot_df[plot_df['Type'] == 8]) + len(plot_df[plot_df['Type'] == 12])
#                         fouls = len(plot_df[plot_df['Type'] == 4])
# 
#                         recoveries = plot_df[((plot_df['Type'] == 7) & (plot_df['Outcome'] == 'Successful')) | (plot_df['Type'].isin([8, 12]))]
#                         avg_rec_height = round(recoveries['x'].mean(), 1) if not recoveries.empty else 0
# 
#                         st.divider()
#                         m1, m2, m3, m4, m5, m6, m7 = st.columns(7)
#                         m1.metric("‚öΩ Passing", f"{succ_passes}/{total_passes}", f"{pass_acc}%")
#                         m2.metric("üéØ Shooting", f"{goals} Goals", f"{total_shots} Shots")
#                         m3.metric("üõ°Ô∏è Def. Actions", f"{total_def}", f"{tackles} Tackles")
#                         m4.metric("‚ö†Ô∏è Discipline", f"{fouls} Fouls", "Committed")
#                         m5.metric("‚öñÔ∏è Field Tilt", f"{field_tilt}%", "Final 3rd Share")
#                         m6.metric("üõë PPDA", f"{ppda}", "Passes per Def. Action")
#                         m7.metric("üìè Def. Line", f"{avg_rec_height}m", "Avg Recovery Height")
#                         st.divider()
# 
#                         vis_options = [
#                             "Actions Leading to Shots", "Counter Attacks (Rapid Transitions)", "Set Piece Targeting (Corners)",
#                             "The Architect (Build-Up Phase)", "Defensive Shield (Heatmap + Line)", "Momentum Map",
#                             "Duel Map (Tackles Won/Lost)", "Game Control (Possession)", "Zone 14 & Half-Spaces",
#                             "Creator Map (Shot Assists)", "Passing Network (Structure)", "Pass Sonar (Radar)",
#                             "Impact Zone (Convex Hull)", "Attacking Zones (5 Lanes)", "Zone Invasions",
#                             "The Pulse (Shot Race)", "The Breakout (Progressive Carries)", "The Air Raid (Crossing Zones)",
#                             "Pass Map", "Passing Heatmap", "Defensive Actions", "General Heatmap",
#                             "Average Offensive Positions", "Average Defensive Positions",
#                             "Matchup: Offense vs Opp. Defense", "Matchup: Defense vs Opp. Offense",
#                             "Zones of Responsibility (Voronoi)", "Expected Threat (xT) Grid",
#                             "Zonal Defensive Pressure Map", "Zonal Passing Control Map", "Switches of Play (>40m)",
#                             "Transition Passing Breakdown", "Defensive Penetration Conceded"
#                         ]
#                         modules = st.multiselect("Evidence Layers", vis_options, default=["Actions Leading to Shots"], key=f"mod_{manager}")
# 
#                         viz_df = plot_df.copy()
#                         is_home_team = viz_df['isHome'].iloc[0] if not viz_df.empty else False
# 
#                         if not is_home_team:
#                             viz_df['x'] = 100 - viz_df['x']
#                             viz_df['y'] = 100 - viz_df['y']
#                             viz_df['endX'] = 100 - viz_df['endX']
#                             viz_df['endY'] = 100 - viz_df['endY']
#                             attack_label = "‚¨ÖÔ∏è Attacking Direction"
#                         else:
#                             attack_label = "Attacking Direction ‚û°Ô∏è"
# 
#                         if "Actions Leading to Shots" in modules:
#                             st.subheader("üé¨ Actions Leading to Shots")
#                             st.info("Traces the creation vector (Pass Origin ‚Üí Exact Shot Location) for each attempt. Filtered for direct involvement.")
# 
#                             sca_filter = st.selectbox("Filter Shot Outcome:",
#                                                       ["All Attempts", "Goals Only", "Saved Only", "Blocked Only", "Missed Only"],
#                                                       key=f"sca_filter_{manager}")
# 
#                             fig_sca, ax_sca = plt.subplots(figsize=(10, 7))
#                             fig_sca.set_facecolor('#0e1117')
#                             ax_sca.set_facecolor('#0e1117')
#                             pitch_sca = Pitch(pitch_type='opta', pitch_color='#0e1117', line_color='white')
#                             pitch_sca.draw(ax=ax_sca)
# 
#                             shots = viz_df[viz_df['Type'].isin([13, 14, 15, 16])]
# 
#                             if sca_filter == "Goals Only":
#                                 shots = shots[(shots['Type'] == 16) & (shots['Outcome'] != 'Own Goal')]
#                             elif sca_filter == "Saved Only":
#                                 shots = shots[(shots['Type'] == 15) & (shots['isBlocked'] == False)]
#                             elif sca_filter == "Blocked Only":
#                                 shots = shots[shots['isBlocked'] == True]
#                             elif sca_filter == "Missed Only":
#                                 shots = shots[~((shots['Type'] == 16) & (shots['Outcome'] != 'Own Goal')) & (shots['isBlocked'] == False) & (shots['Type'] != 15)]
# 
#                             for _, shot in shots.iterrows():
#                                 shot_idx = shot['Index']
#                                 shot_type = shot['Type']
#                                 is_blocked = shot['isBlocked']
# 
#                                 if shot_type == 16 and shot['Outcome'] != 'Own Goal':
#                                     color = '#00ff85' # Goal
#                                     marker = '*'
#                                     size = 400
#                                 elif is_blocked:
#                                     color = '#aaaaaa' # Blocked
#                                     marker = 'X'
#                                     size = 200
#                                 elif shot_type == 15:
#                                     color = '#ffd700' # Saved
#                                     marker = 'o'
#                                     size = 200
#                                 else:
#                                     color = '#ff4b4b' # Missed
#                                     marker = 'x'
#                                     size = 200
# 
#                                 pitch_sca.scatter(shot.x, shot.y, s=size, marker=marker, c=color, edgecolors='white', ax=ax_sca, zorder=4)
# 
#                                 recent_events = viz_df[(viz_df['Index'] < shot_idx) & (viz_df['Index'] >= shot_idx - 10)]
#                                 recent_passes = recent_events[(recent_events['Type'] == 1) & (recent_events['Outcome'] == 'Successful')]
# 
#                                 if not recent_passes.empty:
#                                     last_pass = recent_passes.iloc[-1]
#                                     pitch_sca.arrows(last_pass.x, last_pass.y, shot.x, shot.y,
#                                                      width=2, headwidth=5, color=color, alpha=0.5, ax=ax_sca, zorder=3)
# 
#                             legend_elements = [
#                                 mlines.Line2D([0], [0], marker='*', color='w', label='Goal', markerfacecolor='#00ff85', markersize=15, linestyle='None'),
#                                 mlines.Line2D([0], [0], marker='o', color='w', label='Saved', markerfacecolor='#ffd700', markersize=10, linestyle='None'),
#                                 mlines.Line2D([0], [0], marker='X', color='w', label='Blocked', markerfacecolor='#aaaaaa', markersize=10, linestyle='None'),
#                                 mlines.Line2D([0], [0], marker='x', color='w', label='Missed', markerfacecolor='#ff4b4b', markersize=10, linestyle='None'),
#                                 mlines.Line2D([0], [0], color='w', lw=2, alpha=0.5, label='Creation Vector')
#                             ]
#                             ax_sca.legend(handles=legend_elements, facecolor='#262730', labelcolor='white', loc='upper left')
# 
#                             st.pyplot(fig_sca)
#                             plt.close(fig_sca)
# 
#                         if "Counter Attacks (Rapid Transitions)" in modules:
#                             st.subheader("‚ö° Counter Attacks & Rapid Transitions")
#                             st.info("Maps direct transition passes (Yellow) and traces the build-up sequence (Cyan) leading to explicit 'Fast Break' shots. Fast Break Goals are highlighted in Bright Green.")
# 
#                             fig_ca, ax_ca = plt.subplots(figsize=(10, 7))
#                             fig_ca.set_facecolor('#0e1117')
#                             ax_ca.set_facecolor('#0e1117')
#                             pitch_ca = Pitch(pitch_type='opta', pitch_color='#0e1117', line_color='white')
#                             pitch_ca.draw(ax=ax_ca)
# 
#                             fb_indices = plot_df[(plot_df['Type'].isin([13, 14, 15, 16])) & (plot_df['isFastBreak'] == True)].index
#                             fb_viz = viz_df.loc[fb_indices]
# 
#                             fb_goals = pd.DataFrame()
#                             fb_shots = pd.DataFrame()
#                             if not fb_viz.empty:
#                                 fb_goals = fb_viz[(fb_viz['Type'] == 16) & (fb_viz['Outcome'] != 'Own Goal')]
#                                 fb_shots = fb_viz[~((fb_viz['Type'] == 16) & (fb_viz['Outcome'] != 'Own Goal'))]
# 
#                             buildup_passes = pd.DataFrame()
#                             if not fb_viz.empty:
#                                 blist = []
#                                 for _, row in fb_viz.iterrows():
#                                     ev_idx = row['Index']
#                                     seq = match_df[(match_df['Index'] >= ev_idx - 50) & (match_df['Index'] < ev_idx) & (match_df['Team'] == sel_team) & (match_df['Type'] == 1) & (match_df['Outcome'] == 'Successful')]
#                                     blist.append(seq)
# 
#                                 if blist:
#                                     buildup_passes = pd.concat(blist).drop_duplicates()
#                                     if not is_home_team:
#                                         buildup_passes['x'] = 100 - buildup_passes['x']
#                                         buildup_passes['y'] = 100 - buildup_passes['y']
#                                         buildup_passes['endX'] = 100 - buildup_passes['endX']
#                                         buildup_passes['endY'] = 100 - buildup_passes['endY']
# 
#                             trans_indices = plot_df[(plot_df['Type'] == 1) & (plot_df['Outcome'] == 'Successful') & (plot_df['x'] < 40) & (plot_df['endX'] > 70)].index
#                             trans_viz = viz_df.loc[trans_indices]
# 
#                             if not trans_viz.empty:
#                                 pitch_ca.arrows(trans_viz.x, trans_viz.y, trans_viz.endX, trans_viz.endY, width=2, color='#ffd700', alpha=0.5, ax=ax_ca, label=f'Direct Counter Pass: {len(trans_viz)}')
# 
#                             if not buildup_passes.empty:
#                                 pitch_ca.arrows(buildup_passes.x, buildup_passes.y, buildup_passes.endX, buildup_passes.endY, width=3, color='#00ffff', alpha=0.8, ax=ax_ca, label=f'Fast Break Sequence: {len(buildup_passes)}')
# 
#                             if not fb_shots.empty:
#                                 pitch_ca.scatter(fb_shots.x, fb_shots.y, s=400, marker='*', c='#00ffff', edgecolors='white', ax=ax_ca, label=f'Fast Break Shot: {len(fb_shots)}')
# 
#                             if not fb_goals.empty:
#                                 pitch_ca.scatter(fb_goals.x, fb_goals.y, s=600, marker='*', c='#00ff85', edgecolors='white', linewidth=1.5, ax=ax_ca, label=f'Fast Break Goal: {len(fb_goals)}')
# 
#                             if not trans_viz.empty or not fb_viz.empty or not buildup_passes.empty:
#                                 ax_ca.legend(facecolor='#262730', labelcolor='white')
# 
#                             st.pyplot(fig_ca)
#                             plt.close(fig_ca)
# 
#                         if "Game Control (Possession)" in modules:
#                             st.subheader("üéÆ Game Control: Possession % (Rolling 5-min)")
#                             full = match_df.copy()
#                             full = full[(full['Minute'] >= min_range[0]) & (full['Minute'] <= min_range[1])]
# 
#                             if not full.empty:
#                                 full['MinBin'] = (full['Minute'] // 5) * 5
#                                 poss_data = full[full['Type'] == 1].groupby(['MinBin', 'Team']).size().reset_index(name='Passes')
#                                 poss_pivot = poss_data.pivot(index='MinBin', columns='Team', values='Passes').fillna(0)
#                                 poss_pivot['Total'] = poss_pivot.sum(axis=1)
#                                 if sel_team in poss_pivot.columns:
#                                     poss_pivot['Possession'] = (poss_pivot[sel_team] / poss_pivot['Total']) * 100
#                                     fig_gc = px.area(poss_pivot, x=poss_pivot.index, y='Possession', labels={'MinBin': 'Minute', 'Possession': f'{sel_team} Possession %'}, template="plotly_dark", color_discrete_sequence=['#ff4b4b'])
#                                     fig_gc.update_yaxes(range=[0, 100])
#                                     fig_gc.add_hline(y=50, line_dash="dash", line_color="white", opacity=0.5)
#                                     st.plotly_chart(fig_gc, use_container_width=True)
# 
#                         if "Momentum Map" in modules:
#                             st.subheader("üìà Momentum Gap: Home vs Away")
#                             mom_base = match_df.sort_values("Index").copy()
#                             mom_base = mom_base[(mom_base['Minute'] >= min_range[0]) & (mom_base['Minute'] <= min_range[1])]
# 
#                             if not mom_base.empty:
#                                 mom_base['FinalThirdEntry'] = ((mom_base['Type'] == 1) & (mom_base['Outcome'] == 'Successful') & (mom_base['endX'] > 66.6)).astype(int)
#                                 mom_base['CumulativeThreat'] = mom_base.groupby('Team')['FinalThirdEntry'].cumsum()
#                                 fig_mom = px.line(mom_base, x='Index', y='CumulativeThreat', color='Team', labels={'Index': 'Match Progression', 'CumulativeThreat': 'Attacking Pressure'}, color_discrete_map={sel_team: '#ff4b4b'}, template="plotly_dark")
#                                 opponent = [t for t in teams if t != sel_team][0]
#                                 fig_mom.update_traces(selector=dict(name=opponent), line_color='grey')
#                                 fig_mom.update_layout(paper_bgcolor='#0e1117', plot_bgcolor='#0e1117', legend_title_text='')
#                                 st.plotly_chart(fig_mom, use_container_width=True)
# 
#                         if "The Pulse (Shot Race)" in modules:
#                             st.subheader("üìà The Pulse: Shot Accumulation Race")
#                             shot_race = match_df[match_df['Type'].isin([13, 14, 15, 16])].sort_values("Index").copy()
#                             shot_race = shot_race[(shot_race['Minute'] >= min_range[0]) & (shot_race['Minute'] <= min_range[1])]
# 
#                             if not shot_race.empty:
#                                 shot_race['Count'] = 1
#                                 shot_race['Cumulative Shots'] = shot_race.groupby('Team')['Count'].cumsum()
#                                 fig_pulse = px.line(shot_race, x='Minute', y='Cumulative Shots', color='Team', title='Shot Race', labels={'Minute': 'Match Minute', 'Cumulative Shots': 'Total Shots Taken'}, line_shape='hv', color_discrete_map={sel_team: '#ff4b4b'}, template="plotly_dark")
#                                 opponent = [t for t in teams if t != sel_team][0]
#                                 fig_pulse.update_traces(selector=dict(name=opponent), line_color='grey')
#                                 fig_pulse.update_layout(paper_bgcolor='#0e1117', plot_bgcolor='#0e1117')
#                                 st.plotly_chart(fig_pulse, use_container_width=True)
#                             else: st.write("No shots recorded in this interval.")
# 
#                         if "Set Piece Targeting (Corners)" in modules:
#                             st.subheader("üéØ Set Piece Targeting (Corners)")
#                             st.info("Grid mapped to tactical zones: **Depth** (Edge of Box, Penalty Spot, 6-Yard Box) and **Width** (Far Post, Center, Near Post). Maps Delivery Volume.")
# 
#                             fig_cp, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 7))
#                             fig_cp.set_facecolor('#0e1117')
# 
#                             pitch_half = Pitch(pitch_type='opta', half=True, pitch_color='#0e1117', line_color='white')
#                             pitch_half.draw(ax=ax1)
#                             pitch_half.draw(ax=ax2)
# 
#                             corners = viz_df[(viz_df['Type'] == 1) & (viz_df['isCorner'] == True)]
#                             left_corners = corners[corners['y'] > 50]
#                             right_corners = corners[corners['y'] <= 50]
# 
#                             def draw_corner_grid(ax, corner_data, title):
#                                 ax.set_title(title, color='white', fontsize=16, fontweight='bold', pad=20)
#                                 x_bins = [83.0, 88.5, 94.0, 100.0]
#                                 y_bins = [21.1, 36.8, 63.2, 78.9]
# 
#                                 grid_data = np.zeros((3, 3))
#                                 max_val = 1
# 
#                                 for i in range(3):
#                                     for j in range(3):
#                                         count = len(corner_data[
#                                             (corner_data['endX'] >= x_bins[j]) & (corner_data['endX'] <= x_bins[j+1]) &
#                                             (corner_data['endY'] >= y_bins[i]) & (corner_data['endY'] <= y_bins[i+1])
#                                         ])
#                                         grid_data[i, j] = count
#                                         if count > max_val: max_val = count
# 
#                                 for i in range(3):
#                                     for j in range(3):
#                                         count = grid_data[i, j]
#                                         alpha = count / max_val if max_val > 0 else 0
# 
#                                         if count == 0:
#                                             facecolor = '#fff0e6'
#                                             text_color = 'black'
#                                         else:
#                                             facecolor = plt.cm.Reds(alpha)
#                                             text_color = 'white' if alpha > 0.5 else 'black'
# 
#                                         width = x_bins[j+1] - x_bins[j]
#                                         height = y_bins[i+1] - y_bins[i]
# 
#                                         rect = mpatches.Rectangle((x_bins[j], y_bins[i]), width, height,
#                                                                   linewidth=1.5, edgecolor='black', facecolor=facecolor, alpha=0.9, zorder=2)
#                                         ax.add_patch(rect)
#                                         ax.text(x_bins[j] + (width/2), y_bins[i] + (height/2), str(int(count)),
#                                                 color=text_color, ha='center', va='center', fontweight='bold', fontsize=18, zorder=3)
# 
#                             draw_corner_grid(ax1, left_corners, f"LEFT CORNERS | DELIVERIES")
#                             draw_corner_grid(ax2, right_corners, f"RIGHT CORNERS | DELIVERIES")
# 
#                             st.pyplot(fig_cp)
#                             plt.close(fig_cp)
# 
#                         pitch_modules = [m for m in modules if m not in ["Actions Leading to Shots", "Counter Attacks (Rapid Transitions)", "Momentum Map", "Game Control (Possession)", "Pass Sonar (Radar)", "The Pulse (Shot Race)", "Set Piece Targeting (Corners)"]]
# 
#                         if "Pass Sonar (Radar)" in modules and sel_player != "All Players":
#                             st.subheader(f"üì° Pass Sonar: {sel_player}")
#                             p_passes = plot_df[(plot_df['Type'] == 1) & (plot_df['Outcome'] == 'Successful')]
#                             if not p_passes.empty:
#                                 dx = p_passes['endX'] - p_passes['x']
#                                 dy = p_passes['endY'] - p_passes['y']
#                                 angles = np.arctan2(dy, dx)
#                                 fig_polar = plt.figure(figsize=(6, 6))
#                                 fig_polar.set_facecolor('#0e1117')
#                                 ax_polar = fig_polar.add_subplot(111, polar=True)
#                                 ax_polar.set_facecolor('#0e1117')
#                                 ax_polar.hist(angles, bins=24, color='#ff4b4b', alpha=0.7, edgecolor='white')
#                                 ax_polar.set_theta_zero_location('E')
#                                 ax_polar.set_yticks([])
#                                 ax_polar.grid(color='#262730')
#                                 ax_polar.tick_params(axis='x', colors='white')
#                                 st.pyplot(fig_polar)
#                                 plt.close(fig_polar)
# 
#                         if pitch_modules:
#                             st.markdown(f"<h3 style='text-align: center; color: white;'>{attack_label}</h3>", unsafe_allow_html=True)
#                             fig, ax = plt.subplots(figsize=(10, 7))
#                             fig.set_facecolor('#0e1117')
#                             ax.set_facecolor('#0e1117')
#                             pitch = Pitch(pitch_type='opta', pitch_color='#0e1117', line_color='white')
#                             pitch.draw(ax=ax)
# 
#                             if "Expected Threat (xT) Grid" in pitch_modules:
#                                 xT_grid = np.array([
#                                     [0.00638, 0.00780, 0.00845, 0.00928, 0.01059, 0.01215, 0.01385, 0.01612, 0.01870, 0.02402, 0.02953, 0.03464],
#                                     [0.00679, 0.00843, 0.00923, 0.01019, 0.01166, 0.01349, 0.01548, 0.01816, 0.02120, 0.02756, 0.03508, 0.04097],
#                                     [0.00690, 0.00864, 0.00949, 0.01053, 0.01211, 0.01402, 0.01618, 0.01916, 0.02276, 0.03059, 0.04230, 0.05370],
#                                     [0.00692, 0.00867, 0.00951, 0.01058, 0.01220, 0.01414, 0.01634, 0.01939, 0.02325, 0.03213, 0.05060, 0.25596],
#                                     [0.00692, 0.00867, 0.00951, 0.01058, 0.01220, 0.01414, 0.01634, 0.01939, 0.02325, 0.03213, 0.05060, 0.25596],
#                                     [0.00690, 0.00864, 0.00949, 0.01053, 0.01211, 0.01402, 0.01618, 0.01916, 0.02276, 0.03059, 0.04230, 0.05370],
#                                     [0.00679, 0.00843, 0.00923, 0.01019, 0.01166, 0.01349, 0.01548, 0.01816, 0.02120, 0.02756, 0.03508, 0.04097],
#                                     [0.00638, 0.00780, 0.00845, 0.00928, 0.01059, 0.01215, 0.01385, 0.01612, 0.01870, 0.02402, 0.02953, 0.03464]
#                                 ])
#                                 bin_statistic = pitch.bin_statistic(viz_df.x, viz_df.y, statistic='count', bins=(12, 8))
#                                 bin_statistic['statistic'] = xT_grid
#                                 pitch.heatmap(bin_statistic, ax=ax, cmap='magma', alpha=0.6, edgecolors='#262730', lw=1, zorder=0)
#                                 pitch.label_heatmap(bin_statistic, color='white', fontsize=8, ax=ax, ha='center', va='center', str_format='{:.3f}', zorder=1)
# 
#                             if "Zonal Defensive Pressure Map" in pitch_modules:
#                                 def_events = viz_df[viz_df['Type'].isin([4, 7, 8, 12])]
#                                 x_bins = [0, 33.33, 66.67, 100]
#                                 y_bins = [0, 21.1, 78.9, 100]
#                                 grid_data = np.zeros((3, 3))
#                                 max_val = 1
#                                 for i in range(3):
#                                     for j in range(3):
#                                         count = len(def_events[(def_events['x'] >= x_bins[j]) & (def_events['x'] <= x_bins[j+1]) & (def_events['y'] >= y_bins[i]) & (def_events['y'] <= y_bins[i+1])])
#                                         grid_data[i, j] = count
#                                         if count > max_val: max_val = count
# 
#                                 for i in range(3):
#                                     for j in range(3):
#                                         count = int(grid_data[i, j])
#                                         alpha = min(count / max_val, 0.9) if max_val > 0 else 0
#                                         facecolor = plt.cm.Reds(alpha) if count > 0 else '#0e1117'
#                                         width = x_bins[j+1] - x_bins[j]
#                                         height = y_bins[i+1] - y_bins[i]
#                                         rect = mpatches.Rectangle((x_bins[j], y_bins[i]), width, height, linewidth=1, edgecolor='white', linestyle='--', facecolor=facecolor, alpha=0.7, zorder=1)
#                                         ax.add_patch(rect)
#                                         if count > 0:
#                                             bbox_props = dict(boxstyle="round,pad=0.3", fc="#333333", ec="none", alpha=0.7)
#                                             ax.text(x_bins[j] + (width/2), y_bins[i] + (height/2), str(count), color='white', ha='center', va='center', fontweight='bold', fontsize=18, bbox=bbox_props, zorder=2)
# 
#                             if "Zonal Passing Control Map" in pitch_modules:
#                                 pass_events = viz_df[(viz_df['Type'] == 1) & (viz_df['Outcome'] == 'Successful')]
#                                 x_bins = [0, 33.33, 66.67, 100]
#                                 y_bins = [0, 21.1, 78.9, 100]
#                                 grid_data = np.zeros((3, 3))
#                                 max_val = 1
#                                 for i in range(3):
#                                     for j in range(3):
#                                         count = len(pass_events[(pass_events['x'] >= x_bins[j]) & (pass_events['x'] <= x_bins[j+1]) & (pass_events['y'] >= y_bins[i]) & (pass_events['y'] <= y_bins[i+1])])
#                                         grid_data[i, j] = count
#                                         if count > max_val: max_val = count
# 
#                                 for i in range(3):
#                                     for j in range(3):
#                                         count = int(grid_data[i, j])
#                                         alpha = min(count / max_val, 0.9) if max_val > 0 else 0
#                                         facecolor = plt.cm.Blues(alpha) if count > 0 else '#0e1117'
#                                         width = x_bins[j+1] - x_bins[j]
#                                         height = y_bins[i+1] - y_bins[i]
#                                         rect = mpatches.Rectangle((x_bins[j], y_bins[i]), width, height, linewidth=1, edgecolor='white', linestyle='--', facecolor=facecolor, alpha=0.7, zorder=1)
#                                         ax.add_patch(rect)
#                                         if count > 0:
#                                             bbox_props = dict(boxstyle="round,pad=0.3", fc="#333333", ec="none", alpha=0.7)
#                                             ax.text(x_bins[j] + (width/2), y_bins[i] + (height/2), str(count), color='white', ha='center', va='center', fontweight='bold', fontsize=18, bbox=bbox_props, zorder=2)
# 
#                             if "Switches of Play (>40m)" in pitch_modules:
#                                 passes = viz_df[(viz_df['Type'] == 1) & (viz_df['Outcome'] == 'Successful')]
#                                 switches = passes[abs(passes['endY'] - passes['y']) >= 50]
# 
#                                 if not switches.empty:
#                                     pitch.arrows(switches.x, switches.y, switches.endX, switches.endY, width=2, headwidth=4, color='#00529F', alpha=0.9, ax=ax, zorder=3)
#                                     pitch.scatter(switches.x, switches.y, s=30, color='white', edgecolors='black', ax=ax, zorder=4)
# 
#                                     bbox_props = dict(boxstyle="round,pad=0.5", fc="#00529F", ec="white", lw=2)
#                                     ax.text(85, 5, f"Total Switches: {len(switches)}", color='white', ha='center', va='center', fontweight='bold', fontsize=10, bbox=bbox_props, zorder=5)
# 
#                             if "Transition Passing Breakdown" in pitch_modules:
#                                 trans_passes = viz_df[(viz_df['Type'] == 1) & (viz_df['Outcome'] == 'Successful') &
#                                                       ((viz_df['isFastBreak'] == True) |
#                                                        ((viz_df['x'] < 66.6) & (viz_df['endX'] - viz_df['x'] >= 20)))]
# 
#                                 shots = viz_df[viz_df['Type'].isin([13, 14, 15, 16])]
#                                 goals = shots[(shots['Type'] == 16) & (shots['Outcome'] != 'Own Goal')]
#                                 misses = shots[~((shots['Type'] == 16) & (shots['Outcome'] != 'Own Goal'))]
# 
#                                 if not trans_passes.empty:
#                                     pitch.arrows(trans_passes.x, trans_passes.y, trans_passes.endX, trans_passes.endY, width=2, headwidth=4, color='#ffd700', alpha=0.8, ax=ax, label='Transition Passes', zorder=2)
#                                     bbox_props = dict(boxstyle="round,pad=0.5", fc="#1e1e1e", ec="white", lw=1)
#                                     ax.text(80, 5, f"Total Transition Passes: {len(trans_passes)}", color='white', ha='center', va='center', fontweight='bold', fontsize=10, bbox=bbox_props, zorder=5)
# 
#                                 if not misses.empty:
#                                     pitch.scatter(misses.x, misses.y, s=150, marker='X', color='#ff4b4b', ax=ax, label='Shot (No Goal)', zorder=4)
#                                 if not goals.empty:
#                                     pitch.scatter(goals.x, goals.y, s=300, marker='*', color='#00ff85', edgecolors='white', ax=ax, label='Goal', zorder=5)
# 
#                                 ax.legend(facecolor='#262730', labelcolor='white', loc='lower center', bbox_to_anchor=(0.5, -0.15), ncol=3)
# 
#                             if "Defensive Shield (Heatmap + Line)" in pitch_modules:
#                                 def_heat = viz_df[viz_df['Type'].isin([4, 7, 8, 12])]
#                                 if not def_heat.empty:
#                                     pitch.kdeplot(def_heat.x, def_heat.y, ax=ax, cmap='viridis', fill=True, levels=100, alpha=0.6)
# 
#                                 if avg_rec_height > 0:
#                                     draw_x = avg_rec_height
#                                     if not is_home_team: draw_x = 100 - avg_rec_height
#                                     pitch.lines(draw_x, 0, draw_x, 100, color='#ffd700', lw=3, linestyle='dashed', alpha=0.9, ax=ax, label=f'Avg Def Line ({avg_rec_height}m)')
#                                     if is_home_team: ax.add_patch(mpatches.Rectangle((0, 0), draw_x, 100, alpha=0.1, color='#ffd700', ec=None))
#                                     else: ax.add_patch(mpatches.Rectangle((draw_x, 0), 100-draw_x, 100, alpha=0.1, color='#ffd700', ec=None))
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "The Architect (Build-Up Phase)" in pitch_modules:
#                                 build_up_indices = plot_df[(plot_df['Type'] == 1) & (plot_df['x'] < 33)].index
#                                 build_up_viz = viz_df.loc[build_up_indices]
# 
#                                 if not build_up_viz.empty:
#                                     build_up_viz['norm_endX'] = plot_df.loc[build_up_indices, 'endX']
#                                     circ = build_up_viz[build_up_viz['norm_endX'] < 33]
#                                     prog = build_up_viz[(build_up_viz['norm_endX'] >= 33) & (build_up_viz['norm_endX'] < 66)]
#                                     launch = build_up_viz[build_up_viz['norm_endX'] >= 66]
# 
#                                     pitch.lines(circ.x, circ.y, circ.endX, circ.endY, color='white', alpha=0.1, lw=2, ax=ax, label=f'Circulation: {len(circ)}')
#                                     pitch.lines(prog.x, prog.y, prog.endX, prog.endY, color='#00ffff', alpha=0.6, lw=3, ax=ax, label=f'Progression: {len(prog)}')
#                                     pitch.scatter(prog.endX, prog.endY, s=30, c='#00ffff', ax=ax)
#                                     pitch.lines(launch.x, launch.y, launch.endX, launch.endY, color='#ff00ff', alpha=0.8, lw=3, ax=ax, label=f'Long Ball: {len(launch)}')
#                                     pitch.scatter(launch.endX, launch.endY, s=30, c='#ff00ff', ax=ax)
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Zone 14 & Half-Spaces" in pitch_modules:
#                                 zones = {
#                                     "Zone 14": {"x": (65, 85), "y": (37, 63), "color": "#ffd700"},
#                                     "LHS": {"x": (65, 85), "y": (20, 37), "color": "#ff4b4b"},
#                                     "RHS": {"x": (65, 85), "y": (63, 80), "color": "#ff4b4b"}
#                                 }
# 
#                                 legend_handles = []
# 
#                                 for zone_name, bounds in zones.items():
#                                     xmin, xmax = bounds["x"]
#                                     ymin, ymax = bounds["y"]
#                                     c = bounds["color"]
# 
#                                     rect = mpatches.Rectangle((xmin, ymin), xmax - xmin, ymax - ymin, alpha=0.15, color=c, ec='white', lw=1.5, zorder=1)
#                                     ax.add_patch(rect)
# 
#                                     zone_events = viz_df[(viz_df['x'] >= xmin) & (viz_df['x'] <= xmax) &
#                                                          (viz_df['y'] >= ymin) & (viz_df['y'] <= ymax)]
# 
#                                     succ_passes = zone_events[(zone_events['Type'] == 1) & (zone_events['Outcome'] == 'Successful')]
#                                     succ_dribbles = zone_events[(zone_events['Type'] == 3) & (zone_events['Outcome'] == 'Successful')]
#                                     fail_passes = zone_events[(zone_events['Type'] == 1) & (zone_events['Outcome'] == 'Unsuccessful')]
#                                     fail_dribbles = zone_events[(zone_events['Type'] == 3) & (zone_events['Outcome'] == 'Unsuccessful')]
# 
#                                     succ_count = len(succ_passes) + len(succ_dribbles)
#                                     loss_count = len(fail_passes) + len(fail_dribbles)
# 
#                                     if not succ_passes.empty:
#                                         pitch.arrows(succ_passes.x, succ_passes.y, succ_passes.endX, succ_passes.endY, width=2, headwidth=4, color='white', alpha=0.8, ax=ax, zorder=3)
#                                     if not succ_dribbles.empty:
#                                         pitch.scatter(succ_dribbles.x, succ_dribbles.y, s=100, marker='d', color='#00ffff', edgecolors='white', ax=ax, zorder=4)
# 
#                                     if not fail_passes.empty:
#                                         pitch.arrows(fail_passes.x, fail_passes.y, fail_passes.endX, fail_passes.endY, width=2, headwidth=4, color='#ff4b4b', alpha=0.4, ax=ax, zorder=2)
#                                     if not fail_dribbles.empty:
#                                         pitch.scatter(fail_dribbles.x, fail_dribbles.y, s=100, marker='x', color='#ff4b4b', ax=ax, zorder=4)
# 
#                                     patch_label = mpatches.Patch(color=c, alpha=0.5, label=f"{zone_name} | Succ: {succ_count} | Lost: {loss_count}")
#                                     legend_handles.append(patch_label)
# 
#                                 legend_handles.append(mlines.Line2D([0], [0], color='white', lw=2, label='Succ Pass'))
#                                 legend_handles.append(mlines.Line2D([0], [0], marker='d', color='w', markerfacecolor='#00ffff', markersize=8, linestyle='None', label='Succ Dribble'))
#                                 legend_handles.append(mlines.Line2D([0], [0], color='#ff4b4b', alpha=0.4, lw=2, label='Failed Pass'))
#                                 legend_handles.append(mlines.Line2D([0], [0], marker='x', color='w', markeredgecolor='#ff4b4b', markersize=8, linestyle='None', label='Failed Dribble'))
# 
#                                 ax.legend(handles=legend_handles, facecolor='#262730', labelcolor='white', loc='upper left', bbox_to_anchor=(0, 1.15), ncol=3, fontsize=8)
# 
#                             if "Attacking Zones (5 Lanes)" in pitch_modules:
#                                 f3_acts = plot_df[(plot_df['x'] > 66.6) & (plot_df['Type'] == 1) & (plot_df['Outcome'] == 'Successful')]
#                                 total = len(f3_acts)
#                                 if total > 0:
#                                     c_bottom = len(f3_acts[f3_acts['y'] <= 20])
#                                     c_lower = len(f3_acts[(f3_acts['y'] > 20) & (f3_acts['y'] <= 37)])
#                                     c_center = len(f3_acts[(f3_acts['y'] > 37) & (f3_acts['y'] <= 63)])
#                                     c_upper = len(f3_acts[(f3_acts['y'] > 63) & (f3_acts['y'] <= 80)])
#                                     c_top = len(f3_acts[f3_acts['y'] > 80])
# 
#                                     if is_home_team: lane_labels = ["Right Flank", "Right Half", "Center", "Left Half", "Left Flank"]
#                                     else: lane_labels = ["Left Flank", "Left Half", "Center", "Right Half", "Right Flank"]
#                                     lane_counts = [c_bottom, c_lower, c_center, c_upper, c_top]
# 
#                                     start_x = 66.6 if is_home_team else 0
#                                     y_starts = [0, 20, 37, 63, 80]
#                                     widths = [20, 17, 26, 17, 20]
# 
#                                     for i in range(5):
#                                         pct = (lane_counts[i] / total) * 100
#                                         rect = mpatches.Rectangle((start_x, y_starts[i]), 33.4, widths[i], alpha=min(0.9, max(0.2, pct/40)), color='#ff4b4b', ec='white')
#                                         ax.add_patch(rect)
#                                         ax.text(start_x+16.7, y_starts[i]+(widths[i]/2), f"{lane_labels[i]}\n{pct:.1f}%", color='white', ha='center', va='center', fontweight='bold', fontsize=9)
# 
#                             if "The Breakout (Progressive Carries)" in pitch_modules:
#                                 prog_indices = plot_df[plot_df['endX'] > plot_df['x'] + 10].index
#                                 carries_viz = viz_df.loc[prog_indices]
#                                 if not carries_viz.empty:
#                                     pitch.lines(carries_viz.x, carries_viz.y, carries_viz.endX, carries_viz.endY, lw=3, linestyle='dashed', color='#00ffff', alpha=0.8, ax=ax, label='Prog. Carry (>10m)')
#                                     pitch.scatter(carries_viz.x, carries_viz.y, s=50, c='#00ffff', ax=ax)
#                                     ax.legend(facecolor='#262730', labelcolor='white', title=f"Count: {len(carries_viz)}")
# 
#                             if "The Air Raid (Crossing Zones)" in pitch_modules:
#                                 crosses = viz_df[(viz_df['Type'] == 1) & (viz_df['isCross'] == True)]
#                                 if not crosses.empty:
#                                     succ = crosses[crosses['Outcome'] == 'Successful']
#                                     fail = crosses[crosses['Outcome'] == 'Unsuccessful']
#                                     pitch.arrows(succ.x, succ.y, succ.endX, succ.endY, width=2, color='#00ff85', label='Succ. Cross', ax=ax)
#                                     pitch.arrows(fail.x, fail.y, fail.endX, fail.endY, width=2, color='#ff4b4b', alpha=0.5, label='Failed Cross', ax=ax)
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Duel Map (Tackles Won/Lost)" in pitch_modules:
#                                 duels = viz_df[viz_df['Type'] == 7]
#                                 if not duels.empty:
#                                     won = duels[duels['Outcome'] == 'Successful']
#                                     lost = duels[duels['Outcome'] == 'Unsuccessful']
#                                     pitch.scatter(won.x, won.y, s=200, marker='p', c='#00ff85', edgecolors='black', ax=ax, label='Tackle Won')
#                                     pitch.scatter(lost.x, lost.y, s=200, marker='X', c='#ff4b4b', edgecolors='white', ax=ax, label='Tackle Lost')
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Passing Network (Structure)" in pitch_modules:
#                                 net_df = viz_df.copy()
#                                 avg_pos = net_df.groupby('Player')[['x', 'y']].mean()
#                                 pass_counts = net_df.groupby('Player').size()
#                                 net_df['NextPlayer'] = net_df['Player'].shift(-1)
#                                 net_df['NextTeam'] = net_df['Team'].shift(-1)
#                                 connections = net_df[(net_df['Type'] == 1) & (net_df['Outcome'] == 'Successful') & (net_df['NextTeam'] == sel_team)]
#                                 if not connections.empty:
#                                     edges = connections.groupby(['Player', 'NextPlayer']).size().reset_index(name='count')
#                                     edges = edges[edges['count'] > 2]
#                                     for _, row in edges.iterrows():
#                                         p1, p2 = row['Player'], row['NextPlayer']
#                                         if p1 in avg_pos.index and p2 in avg_pos.index:
#                                             width = row['count'] * 0.5
#                                             pitch.lines(avg_pos.loc[p1].x, avg_pos.loc[p1].y, avg_pos.loc[p2].x, avg_pos.loc[p2].y, lw=width, color='#ff4b4b', alpha=0.6, ax=ax, zorder=1)
#                                     pitch.scatter(avg_pos.x, avg_pos.y, s=pass_counts*5, color='#0e1117', edgecolors='white', linewidth=2, ax=ax, zorder=2)
#                                     for player, row in avg_pos.iterrows():
#                                         pitch.annotate(player.split(" ")[-1], xy=(row.x, row.y), c='white', va='center', ha='center', size=8, ax=ax, zorder=3)
# 
#                             if "Impact Zone (Convex Hull)" in pitch_modules:
#                                 def_pts = viz_df[viz_df['Type'].isin([4, 7, 8, 12])][['x', 'y']]
#                                 if len(def_pts) >= 3:
#                                     hull = ConvexHull(def_pts[['x', 'y']].values)
#                                     hull_pts = def_pts[['x', 'y']].values[hull.vertices]
#                                     hull_pts = np.vstack((hull_pts, hull_pts[0]))
#                                     poly = mpatches.Polygon(hull_pts, closed=True, facecolor='#ff4b4b', alpha=0.3, edgecolor='white', lw=2)
#                                     ax.add_patch(poly)
#                                     pitch.scatter(def_pts.x, def_pts.y, s=50, c='#ff4b4b', ax=ax, alpha=0.6)
# 
#                             if "Pass Map" in pitch_modules:
#                                 passes = viz_df[viz_df['Type'] == 1]
#                                 if not passes.empty:
#                                     succ = passes[passes['Outcome'] == 'Successful']
#                                     fail = passes[passes['Outcome'] == 'Unsuccessful']
#                                     pitch.arrows(succ.x, succ.y, succ.endX, succ.endY, width=2, color='#00ff85', alpha=0.3, ax=ax)
#                                     pitch.arrows(fail.x, fail.y, fail.endX, fail.endY, width=2, color='#ff4b4b', alpha=0.3, ax=ax)
# 
#                             if "Zone Invasions" in pitch_modules:
#                                 passes = viz_df[(viz_df['Type'] == 1) & (viz_df['Outcome'] == 'Successful')]
#                                 dribbles_won = viz_df[(viz_df['Type'] == 3) & (viz_df['Outcome'] == 'Successful')]
# 
#                                 if is_home_team:
#                                     f3_pass = passes[(passes['endX'] > 66) & (passes['endX'] <= 83)]
#                                     box_pass = passes[passes['endX'] > 83]
#                                     drib_won = dribbles_won[dribbles_won['x'] > 66]
#                                 else:
#                                     f3_pass = passes[(passes['endX'] < 33) & (passes['endX'] >= 17)]
#                                     box_pass = passes[passes['endX'] < 17]
#                                     drib_won = dribbles_won[dribbles_won['x'] < 33]
# 
#                                 if not f3_pass.empty:
#                                     pitch.arrows(f3_pass.x, f3_pass.y, f3_pass.endX, f3_pass.endY, width=3, color='white', alpha=0.6, ax=ax, label='Into F3')
#                                 if not box_pass.empty:
#                                     pitch.arrows(box_pass.x, box_pass.y, box_pass.endX, box_pass.endY, width=3, color='#ffd700', alpha=0.9, ax=ax, label='Into Box')
#                                 if not drib_won.empty:
#                                     pitch.scatter(drib_won.x, drib_won.y, s=150, marker='d', c='#00ffff', edgecolors='white', ax=ax, label='Succ. Dribble')
#                                 ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Defensive Actions" in pitch_modules:
#                                 def_act = viz_df[viz_df['Type'].isin([4, 7, 8, 12])]
#                                 if not def_act.empty:
#                                     t = def_act[def_act['Type'] == 7]
#                                     i = def_act[def_act['Type'] == 8]
#                                     f = def_act[def_act['Type'] == 4]
#                                     pitch.scatter(t.x, t.y, s=150, marker='d', c='#3399ff', edgecolors='white', ax=ax, label='Tackle')
#                                     pitch.scatter(i.x, i.y, s=150, marker='s', c='#ff9900', edgecolors='black', ax=ax, label='Interception')
#                                     pitch.scatter(f.x, f.y, s=150, marker='X', c='#ff4b4b', ax=ax, label='Foul')
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Creator Map (Shot Assists)" in pitch_modules:
#                                 shots = viz_df[viz_df['Type'].isin([13, 14, 15, 16])]
#                                 assists = []
#                                 key_passes = []
# 
#                                 for _, shot in shots.iterrows():
#                                     shot_idx = shot['Index']
#                                     prev_events = viz_df[(viz_df['Index'] < shot_idx) & (viz_df['Index'] >= shot_idx - 5)]
#                                     passes = prev_events[(prev_events['Type'] == 1) & (prev_events['Outcome'] == 'Successful')]
# 
#                                     if not passes.empty:
#                                         key_pass = passes.iloc[-1]
#                                         if shot['Type'] == 16 and shot['Outcome'] != 'Own Goal':
#                                             assists.append(key_pass)
#                                         else:
#                                             key_passes.append(key_pass)
# 
#                                 if key_passes:
#                                     kp_df = pd.DataFrame(key_passes)
#                                     pitch.arrows(kp_df.x, kp_df.y, kp_df.endX, kp_df.endY, width=2, headwidth=4, color='#00ffff', alpha=0.7, ax=ax, label=f'Key Pass ({len(kp_df)})')
#                                     pitch.scatter(kp_df.x, kp_df.y, s=60, color='#00ffff', edgecolors='white', ax=ax, zorder=3)
# 
#                                 if assists:
#                                     ast_df = pd.DataFrame(assists)
#                                     pitch.arrows(ast_df.x, ast_df.y, ast_df.endX, ast_df.endY, width=3, headwidth=5, color='#ffd700', alpha=0.9, ax=ax, label=f'Assist ({len(ast_df)})')
#                                     pitch.scatter(ast_df.x, ast_df.y, s=200, marker='*', color='#ffd700', edgecolors='black', ax=ax, zorder=4)
# 
#                                 if key_passes or assists:
#                                     ax.legend(facecolor='#262730', labelcolor='white')
#                                 else:
#                                     pitch.annotate("No Shot Assists Recorded", xy=(50, 50), c='white', ha='center', va='center', size=15, ax=ax)
# 
#                             if "Average Offensive Positions" in pitch_modules:
#                                 off_events = viz_df[viz_df['Type'].isin([1, 3])]
#                                 if not off_events.empty:
#                                     off_avg = off_events.groupby('Player')[['x', 'y']].mean()
#                                     pitch.scatter(off_avg.x, off_avg.y, s=150, c='#00ffff', edgecolors='white', ax=ax, zorder=3, label='Avg Offensive Position')
#                                     for player, row in off_avg.iterrows():
#                                         last_name = player.split(" ")[-1]
#                                         pitch.annotate(last_name, xy=(row.x, row.y + 3), c='white', ha='center', va='center', size=9, fontweight='bold', ax=ax, zorder=4)
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Average Defensive Positions" in pitch_modules:
#                                 def_events = viz_df[viz_df['Type'].isin([4, 7, 8, 12])]
#                                 if not def_events.empty:
#                                     def_avg = def_events.groupby('Player')[['x', 'y']].mean()
#                                     pitch.scatter(def_avg.x, def_avg.y, s=150, c='#ff4b4b', edgecolors='white', marker='s', ax=ax, zorder=3, label='Avg Defensive Position')
#                                     for player, row in def_avg.iterrows():
#                                         last_name = player.split(" ")[-1]
#                                         pitch.annotate(last_name, xy=(row.x, row.y + 3), c='white', ha='center', va='center', size=9, fontweight='bold', ax=ax, zorder=4)
#                                     ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             # Prepare Opponent Visual Data for Matchups
#                             if "Matchup: Offense vs Opp. Defense" in pitch_modules or "Matchup: Defense vs Opp. Offense" in pitch_modules:
#                                 opp_viz = opp_stats.copy()
#                                 if not opp_viz.empty:
#                                     opp_is_home = opp_viz['isHome'].iloc[0]
#                                     if not opp_is_home:
#                                         opp_viz['x'] = 100 - opp_viz['x']
#                                         opp_viz['y'] = 100 - opp_viz['y']
# 
#                             if "Matchup: Offense vs Opp. Defense" in pitch_modules:
#                                 off_events = viz_df[viz_df['Type'].isin([1, 3])]
#                                 def_events = opp_viz[opp_viz['Type'].isin([4, 7, 8, 12])] if not opp_viz.empty else pd.DataFrame()
# 
#                                 if not off_events.empty:
#                                     off_avg = off_events.groupby('Player')[['x', 'y']].mean()
#                                     pitch.scatter(off_avg.x, off_avg.y, s=150, c='#00ffff', edgecolors='white', ax=ax, zorder=3, label=f'{sel_team} (Off)')
#                                     for player, row in off_avg.iterrows():
#                                         pitch.annotate(player.split(" ")[-1], xy=(row.x, row.y + 3), c='white', ha='center', va='center', size=9, fontweight='bold', ax=ax, zorder=4)
# 
#                                 if not def_events.empty:
#                                     def_avg = def_events.groupby('Player')[['x', 'y']].mean()
#                                     pitch.scatter(def_avg.x, def_avg.y, s=150, c='#ff4b4b', edgecolors='white', marker='s', ax=ax, zorder=3, label=f'{opp_team} (Def)')
#                                     for player, row in def_avg.iterrows():
#                                         pitch.annotate(player.split(" ")[-1], xy=(row.x, row.y + 3), c='white', ha='center', va='center', size=9, fontweight='bold', ax=ax, zorder=4)
# 
#                                 ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Matchup: Defense vs Opp. Offense" in pitch_modules:
#                                 def_events = viz_df[viz_df['Type'].isin([4, 7, 8, 12])]
#                                 off_events = opp_viz[opp_viz['Type'].isin([1, 3])] if not opp_viz.empty else pd.DataFrame()
# 
#                                 if not def_events.empty:
#                                     def_avg = def_events.groupby('Player')[['x', 'y']].mean()
#                                     pitch.scatter(def_avg.x, def_avg.y, s=150, c='#ff4b4b', edgecolors='white', marker='s', ax=ax, zorder=3, label=f'{sel_team} (Def)')
#                                     for player, row in def_avg.iterrows():
#                                         pitch.annotate(player.split(" ")[-1], xy=(row.x, row.y + 3), c='white', ha='center', va='center', size=9, fontweight='bold', ax=ax, zorder=4)
# 
#                                 if not off_events.empty:
#                                     off_avg = off_events.groupby('Player')[['x', 'y']].mean()
#                                     pitch.scatter(off_avg.x, off_avg.y, s=150, c='#00ffff', edgecolors='white', ax=ax, zorder=3, label=f'{opp_team} (Off)')
#                                     for player, row in off_avg.iterrows():
#                                         pitch.annotate(player.split(" ")[-1], xy=(row.x, row.y + 3), c='white', ha='center', va='center', size=9, fontweight='bold', ax=ax, zorder=4)
# 
#                                 ax.legend(facecolor='#262730', labelcolor='white')
# 
#                             if "Defensive Penetration Conceded" in pitch_modules:
#                                 # Apply coordinate flip to perfectly align the opponent's attack against your defense
#                                 opp_pen_df = opp_stats.copy()
#                                 if not opp_pen_df.empty:
#                                     opp_is_home = opp_pen_df['isHome'].iloc[0]
#                                     if not opp_is_home:
#                                         opp_pen_df['x'] = 100 - opp_pen_df['x']
#                                         opp_pen_df['y'] = 100 - opp_pen_df['y']
#                                         opp_pen_df['endX'] = 100 - opp_pen_df['endX']
#                                         opp_pen_df['endY'] = 100 - opp_pen_df['endY']
# 
#                                 opp_passes = opp_pen_df[(opp_pen_df['Type'] == 1) & (opp_pen_df['Outcome'] == 'Successful')]
# 
#                                 if is_home_team:
#                                     box_passes = opp_passes[(opp_passes['endX'] <= 17) & (opp_passes['x'] > 17) & (opp_passes['endY'] >= 21.1) & (opp_passes['endY'] <= 78.9)]
#                                     z14_passes = opp_passes[(opp_passes['endX'] > 17) & (opp_passes['endX'] <= 35) & (opp_passes['x'] > 35) & (opp_passes['endY'] >= 37) & (opp_passes['endY'] <= 63)]
# 
#                                     rect_box = mpatches.Rectangle((0, 21.1), 17, 57.8, alpha=0.15, color='#ff4b4b', ec=None, zorder=1)
#                                     rect_z14 = mpatches.Rectangle((17, 37), 18, 26, alpha=0.15, color='#ffd700', ec=None, zorder=1)
#                                 else:
#                                     box_passes = opp_passes[(opp_passes['endX'] >= 83) & (opp_passes['x'] < 83) & (opp_passes['endY'] >= 21.1) & (opp_passes['endY'] <= 78.9)]
#                                     z14_passes = opp_passes[(opp_passes['endX'] < 83) & (opp_passes['endX'] >= 65) & (opp_passes['x'] < 65) & (opp_passes['endY'] >= 37) & (opp_passes['endY'] <= 63)]
# 
#                                     rect_box = mpatches.Rectangle((83, 21.1), 17, 57.8, alpha=0.15, color='#ff4b4b', ec=None, zorder=1)
#                                     rect_z14 = mpatches.Rectangle((65, 37), 18, 26, alpha=0.15, color='#ffd700', ec=None, zorder=1)
# 
#                                 ax.add_patch(rect_box)
#                                 ax.add_patch(rect_z14)
# 
#                                 def_acts = viz_df[viz_df['Type'].isin([4, 7, 8, 12])]
#                                 if not def_acts.empty:
#                                     pitch.scatter(def_acts.x, def_acts.y, s=30, marker='s', color='#262730', edgecolors='white', alpha=0.6, ax=ax, zorder=2, label='Our Def. Actions')
# 
#                                 # Look-ahead function: Scans the next 10 match events to see if a goal was scored
#                                 def split_by_goal(pass_df):
#                                     fatal = []
#                                     safe = []
#                                     for _, p in pass_df.iterrows():
#                                         future_events = match_df[(match_df['Index'] > p['Index']) & (match_df['Index'] <= p['Index'] + 10)]
#                                         goals = future_events[(future_events['Type'] == 16) & (future_events['Team'] == opp_team) & (future_events['Outcome'] != 'Own Goal')]
#                                         if not goals.empty:
#                                             fatal.append(p)
#                                         else:
#                                             safe.append(p)
#                                     return pd.DataFrame(fatal), pd.DataFrame(safe)
# 
#                                 fatal_box, safe_box = split_by_goal(box_passes)
#                                 fatal_z14, safe_z14 = split_by_goal(z14_passes)
# 
#                                 # Plot normal box passes
#                                 if not safe_box.empty:
#                                     pitch.arrows(safe_box.x, safe_box.y, safe_box.endX, safe_box.endY, width=2, headwidth=4, color='#ff4b4b', alpha=0.6, ax=ax, label=f'Box Conceded ({len(safe_box)})', zorder=4)
#                                     pitch.scatter(safe_box.x, safe_box.y, s=40, color='#ff4b4b', edgecolors='white', ax=ax, zorder=4)
# 
#                                 # Plot FATAL box passes (Led to Goal)
#                                 if not fatal_box.empty:
#                                     pitch.arrows(fatal_box.x, fatal_box.y, fatal_box.endX, fatal_box.endY, width=3, headwidth=5, color='#00ff85', alpha=1.0, ax=ax, label=f'Fatal Box Pass ({len(fatal_box)})', zorder=5)
#                                     pitch.scatter(fatal_box.endX, fatal_box.endY, s=250, marker='*', color='#00ff85', edgecolors='black', ax=ax, zorder=6)
# 
#                                 # Plot normal z14 passes
#                                 if not safe_z14.empty:
#                                     pitch.arrows(safe_z14.x, safe_z14.y, safe_z14.endX, safe_z14.endY, width=2, headwidth=4, color='#ffd700', alpha=0.6, ax=ax, label=f'Pocket Conceded ({len(safe_z14)})', zorder=3)
#                                     pitch.scatter(safe_z14.x, safe_z14.y, s=40, color='#ffd700', edgecolors='black', ax=ax, zorder=3)
# 
#                                 # Plot FATAL z14 passes (Led to Goal)
#                                 if not fatal_z14.empty:
#                                     pitch.arrows(fatal_z14.x, fatal_z14.y, fatal_z14.endX, fatal_z14.endY, width=3, headwidth=5, color='#00ff85', alpha=1.0, ax=ax, label=f'Fatal Pocket Pass ({len(fatal_z14)})', zorder=5)
#                                     pitch.scatter(fatal_z14.endX, fatal_z14.endY, s=250, marker='*', color='#00ff85', edgecolors='black', ax=ax, zorder=6)
# 
#                                 if box_passes.empty and z14_passes.empty:
#                                     pitch.annotate("No Major Defensive Penetrations Conceded", xy=(50, 50), c='white', ha='center', va='center', size=12, ax=ax)
#                                 else:
#                                     ax.legend(facecolor='#262730', labelcolor='white', loc='upper right', bbox_to_anchor=(1, 1.15), ncol=2, fontsize=8)
# 
#                             if "Zones of Responsibility (Voronoi)" in pitch_modules:
#                                 team_avg = viz_df.groupby('Player')[['x', 'y']].mean().reset_index()
#                                 if len(team_avg) >= 4:
#                                     x_vals = team_avg['x'].values
#                                     y_vals = team_avg['y'].values
#                                     try:
#                                         team_vor, _ = pitch.voronoi(x_vals, y_vals, team_avg['Player'].values)
#                                         pitch.polygon(team_vor, ax=ax, fc='#ff4b4b', ec='white', lw=2, alpha=0.2, zorder=1)
#                                     except ValueError:
#                                         team_vor = pitch.voronoi(x_vals, y_vals)
#                                         pitch.polygon(team_vor, ax=ax, fc='#ff4b4b', ec='white', lw=2, alpha=0.2, zorder=1)
#                                     pitch.scatter(x_vals, y_vals, s=150, c='#ff4b4b', edgecolors='white', ax=ax, zorder=3)
#                                     for _, row in team_avg.iterrows():
#                                         last_name = row['Player'].split(" ")[-1]
#                                         pitch.annotate(last_name, xy=(row.x, row.y + 2.5), c='white', ha='center', va='center', size=9, fontweight='bold', ax=ax, zorder=4)
# 
#                             if "Passing Heatmap" in pitch_modules:
#                                 passes_heat = viz_df[viz_df['Type'] == 1]
#                                 if not passes_heat.empty:
#                                     pitch.kdeplot(passes_heat.x, passes_heat.y, ax=ax, cmap='plasma', fill=True, levels=100, alpha=0.6)
# 
#                             if "General Heatmap" in pitch_modules and not viz_df.empty:
#                                 pitch.kdeplot(viz_df.x, viz_df.y, ax=ax, cmap='hot', fill=True, levels=100, alpha=0.6)
# 
#                             st.pyplot(fig)
#                             plt.close(fig)
#                     else: st.error(f"Error: {err}")
# 
#         # === TAB C: PLAYER PROFILE ===
#         with sub_t3:
#             files = CASE_DATABASE[manager]["json_files"]
#             options = list(files.keys())
# 
#             if options:
#                 selected_match_p = st.selectbox("Select Match", options, key=f"mp_{manager}")
#                 target_path_p = files.get(selected_match_p, "")
# 
#                 if target_path_p:
#                     with st.spinner("Analyzing Player Data..."):
#                         match_df_p, err = load_match_data(target_path_p)
# 
#                     if match_df_p is not None and not match_df_p.empty:
#                         teams_p = match_df_p['Team'].unique()
#                         c1_p, c2_p, c3_p = st.columns(3)
#                         sel_team_p = c1_p.selectbox("Squad", teams_p, key=f"stp_{manager}")
# 
#                         team_players_p = sorted(match_df_p[match_df_p['Team']==sel_team_p]['Player'].unique())
#                         sel_player_p = c2_p.selectbox("Player", team_players_p, key=f"spp_{manager}")
# 
#                         max_minute_p = int(match_df_p['Minute'].max()) if not match_df_p.empty else 95
#                         min_range_p = c3_p.slider("Minute Range", 0, max_minute_p, (0, max_minute_p), key=f"sperp_{manager}")
# 
#                         player_df = match_df_p[(match_df_p['Player'] == sel_player_p) &
#                                                (match_df_p['Minute'] >= min_range_p[0]) &
#                                                (match_df_p['Minute'] <= min_range_p[1])].copy()
# 
#                         is_home_p = player_df['isHome'].iloc[0] if not player_df.empty else (match_df_p[match_df_p['Team']==sel_team_p]['isHome'].iloc[0])
# 
#                         if not is_home_p and not player_df.empty:
#                             player_df['x'] = 100 - player_df['x']
#                             player_df['y'] = 100 - player_df['y']
#                             player_df['endX'] = 100 - player_df['endX']
#                             player_df['endY'] = 100 - player_df['endY']
# 
#                         st.markdown(f"### üë§ {sel_player_p.upper()} | ISOLATED REPORT")
#                         st.divider()
# 
#                         pc1, pc2 = st.columns(2)
# 
#                         with pc1:
#                             st.markdown("**Pass Map & Action Heatmap**")
#                             fig_p1, ax_p1 = plt.subplots(figsize=(7, 5))
#                             fig_p1.set_facecolor('#0e1117')
#                             ax_p1.set_facecolor('#0e1117')
#                             pitch_p1 = Pitch(pitch_type='opta', pitch_color='#0e1117', line_color='white')
#                             pitch_p1.draw(ax=ax_p1)
# 
#                             if not player_df.empty:
#                                 passes = player_df[player_df['Type'] == 1]
#                                 succ = passes[passes['Outcome'] == 'Successful']
#                                 fail = passes[passes['Outcome'] == 'Unsuccessful']
# 
#                                 if not passes.empty:
#                                     pitch_p1.kdeplot(passes.x, passes.y, ax=ax_p1, cmap='plasma', fill=True, levels=50, alpha=0.4)
# 
#                                 pitch_p1.arrows(succ.x, succ.y, succ.endX, succ.endY, width=2, color='#00ff85', alpha=0.7, ax=ax_p1, label='Successful')
#                                 pitch_p1.arrows(fail.x, fail.y, fail.endX, fail.endY, width=2, color='#ff4b4b', alpha=0.7, ax=ax_p1, label='Unsuccessful')
#                                 ax_p1.legend(facecolor='#262730', labelcolor='white', loc='upper left', fontsize=8)
#                             st.pyplot(fig_p1)
#                             plt.close(fig_p1)
# 
#                         with pc2:
#                             st.markdown("**Pass Sonar (Distribution Angles)**")
#                             p_passes = player_df[(player_df['Type'] == 1) & (player_df['Outcome'] == 'Successful')]
#                             if not p_passes.empty:
#                                 dx = p_passes['endX'] - p_passes['x']
#                                 dy = p_passes['endY'] - p_passes['y']
#                                 angles = np.arctan2(dy, dx)
#                                 fig_polar = plt.figure(figsize=(5, 5))
#                                 fig_polar.set_facecolor('#0e1117')
#                                 ax_polar = fig_polar.add_subplot(111, polar=True)
#                                 ax_polar.set_facecolor('#0e1117')
#                                 ax_polar.hist(angles, bins=24, color='#00ffff', alpha=0.7, edgecolor='white')
#                                 ax_polar.set_theta_zero_location('E')
#                                 ax_polar.set_yticks([])
#                                 ax_polar.grid(color='#262730')
#                                 ax_polar.tick_params(axis='x', colors='white')
#                                 st.pyplot(fig_polar)
#                                 plt.close(fig_polar)
#                             else:
#                                 st.info("Not enough successful passes for sonar distribution.")
# 
#                         st.divider()
# 
#                         # --- OFFENSIVE METRICS ---
#                         st.markdown("#### ‚öîÔ∏è OFFENSIVE INVOLVEMENT")
#                         mc1, mc2, mc3, mc4 = st.columns(4)
#                         total_p_passes = len(player_df[player_df['Type'] == 1])
#                         succ_p_passes = len(player_df[(player_df['Type'] == 1) & (player_df['Outcome'] == 'Successful')])
#                         p_acc = round((succ_p_passes / total_p_passes * 100), 1) if total_p_passes > 0 else 0
#                         p_shots = len(player_df[player_df['Type'].isin([13, 14, 15, 16])])
#                         prog_carries = len(player_df[player_df['endX'] > player_df['x'] + 10])
#                         dribbles_won = len(player_df[(player_df['Type'] == 3) & (player_df['Outcome'] == 'Successful')])
# 
#                         mc1.metric("üëü Passes", f"{succ_p_passes}/{total_p_passes}", f"{p_acc}% Acc")
#                         mc2.metric("üéØ Shots", p_shots)
#                         mc3.metric("üèÉ‚Äç‚ôÇÔ∏è Prog. Carries (>10m)", prog_carries)
#                         mc4.metric("‚ú® Succ. Dribbles", dribbles_won)
# 
#                         st.divider()
# 
#                         # --- DEFENSIVE INTEGRITY METRICS ---
#                         st.markdown("#### üõ°Ô∏è DEFENSIVE INTEGRITY")
#                         dc1, dc2, dc3, dc4 = st.columns(4)
# 
#                         tackles_won = len(player_df[(player_df['Type'] == 7) & (player_df['Outcome'] == 'Successful')])
#                         tackles_lost = len(player_df[(player_df['Type'] == 7) & (player_df['Outcome'] == 'Unsuccessful')])
#                         fouls_committed = len(player_df[player_df['Type'] == 4])
#                         interceptions = len(player_df[player_df['Type'] == 8])
# 
#                         # True Tackle Win Rate Calculation
#                         total_engagements = tackles_won + tackles_lost + fouls_committed
#                         true_tackle_rate = round((tackles_won / total_engagements * 100), 1) if total_engagements > 0 else 0
# 
#                         dc1.metric("‚úÖ Tackles & Interceptions", tackles_won + interceptions, f"{interceptions} Interceptions")
#                         dc2.metric("‚ùå Challenges Lost", tackles_lost, "Dribbled Past")
#                         dc3.metric("‚ö†Ô∏è Fouls Committed", fouls_committed)
# 
#                         # Color code the True Tackle Rate (Red if under 50%)
#                         if true_tackle_rate >= 50:
#                             dc4.metric("‚öñÔ∏è True Tackle Win Rate", f"{true_tackle_rate}%", f"{tackles_won}/{total_engagements} Engagements")
#                         else:
#                             dc4.metric("‚öñÔ∏è True Tackle Win Rate", f"{true_tackle_rate}%", f"-{total_engagements - tackles_won} Failed Engagements")

!streamlit run forensics_app.py &>/dev/null &
!./cloudflared-linux-amd64 tunnel --url http://localhost:8501