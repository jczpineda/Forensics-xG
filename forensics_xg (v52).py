# -*- coding: utf-8 -*-
"""Forensics xG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HXahst9EouNaxkFii2bNbwgR_lbGrts5
"""

# Install all required libraries
!pip install -q streamlit mplsoccer pandas matplotlib numpy

print("‚úÖ All libraries installed successfully!")

!wget -q -O - ipv4.icanhazip.com

import os
import shutil

# DELETE existing config to remove any "Invisible UI" bugs
if os.path.exists('.streamlit'):
    shutil.rmtree('.streamlit')

# Write the SAFEST possible config
os.makedirs('.streamlit', exist_ok=True)
config_content = """
[theme]
base="dark"
[server]
headless = true
enableCORS = false
"""
with open('.streamlit/config.toml', 'w') as f:
    f.write(config_content)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile forensics_app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import json
# import requests
# from mplsoccer import Pitch
# import plotly.express as px
# from io import BytesIO
# from urllib.parse import quote
# from datetime import datetime
# 
# # --- 1. CONFIGURATION ---
# st.set_page_config(page_title="Forensics xG", layout="wide", page_icon="üß¨")
# 
# # üö® USER DATABASE üö®
# CASE_DATABASE = {
#     "RUBEN AMORIM": {
#         "json_files": {
#             "Manchester United vs Arsenal": "amorim.json/Arsenal.JSON"
#         },
#         "stats_files": {
#             "üß§ GK Advanced (Against)": "amorim.csv/Advanced Goalkeeper Stats Against (2025-2026).xlsx",
#             "üß§ GK Advanced (For)": "amorim.csv/Advanced Goalkeeper Stats For (2025-2026).xlsx",
#             "üß§ GK Standard (Against)": "amorim.csv/Goalkeeper Stats Against (2025-2026).xlsx",
#             "üß§ GK Standard (For)": "amorim.csv/Goalkeeper Stats For (2025-2026).xlsx",
#             "üéØ Shooting (Against)": "amorim.csv/Shooting Against (2025-2026).xlsx",
#             "üéØ Shooting (For)": "amorim.csv/Shooting For (2025-2026).xlsx",
#             "‚ö° Goal/Shot Creation (Against)": "amorim.csv/Squad Goal and Shot Creation Against (2025-2026).xlsx",
#             "‚ö° Goal/Shot Creation (For)": "amorim.csv/Squad Goal and Shot Creation For (2025-2026).xlsx",
#             "‚öΩ Passing (Against)": "amorim.csv/Passing Against (2025-2026).xlsx",
#             "‚öΩ Passing (For)": "amorim.csv/Passing For (2025-2026).xlsx",
#             "üß† Passing Types (Against)": "amorim.csv/Passing Types Against (2025-2026).xlsx",
#             "üß† Passing Types (For)": "amorim.csv/Passing Types For (2025-2026).xlsx",
#             "‚è≥ Possession (Against)": "amorim.csv/Possession Against (2025-2026).xlsx",
#             "‚è≥ Possession (For)": "amorim.csv/Possession For (2025-2026).xlsx",
#             "üõ°Ô∏è Squad Defense (Against)": "amorim.csv/Squad Defense Against (2025-2026).xlsx",
#             "üõ°Ô∏è Squad Defense (For)": "amorim.csv/Squad Defense For (2025-2026).xlsx",
#             "üèÜ Overall Results": "amorim.csv/Overall Results (2025-2026).xlsx",
#             "üè† Home/Away Results": "amorim.csv/Home-Away Results (2025-2026).xlsx",
#             "‚è±Ô∏è Playing Time (Against)": "amorim.csv/Playing Time Against (2025-2026).xlsx",
#             "‚è±Ô∏è Playing Time (For)": "amorim.csv/Playing Time For (2025-2026).xlsx",
#             "üìä Standard Stats (Against)": "amorim.csv/Standard Stats Against (2025-2026).xlsx",
#             "üìä Standard Stats (For)": "amorim.csv/Standard Stats For (2025-2026).xlsx",
#             "üß© Misc Stats (Against)": "amorim.csv/Miscellaneous Stats Against (2025-2026).xlsx",
#             "üß© Misc Stats (For)": "amorim.csv/Miscellaneous Stats For (2025-2026).xlsx",
#         }
#     },
#     "DARREN FLETCHER": {
#         "json_files": {},
#         "stats_files": {}
#     },
#     "MICHAEL CARRICK": {
#         "json_files": {},
#         "stats_files": {}
#     }
# }
# 
# GITHUB_BASE = "https://raw.githubusercontent.com/jczpineda/Forensics-xG/main/"
# 
# # --- 2. STYLING (CLEANED UP) ---
# st.markdown("""
#     <style>
#     /* Main Background */
#     .stApp { background-color: #0e1117; }
# 
#     /* Sidebar Styling */
#     [data-testid="stSidebar"] { background-color: #1e1e1e !important; border-right: 1px solid #444 !important; }
#     [data-testid="stSidebar"] h1, [data-testid="stSidebar"] span, [data-testid="stSidebar"] p { color: #ffffff !important; }
# 
#     /* Input/Select Styling */
#     div[data-baseweb="select"] > div { background-color: #262730 !important; border: 1px solid #ff4b4b !important; color: white !important; }
# 
#     /* Tab Styling */
#     .stTabs [data-baseweb="tab-list"] { gap: 10px; }
#     .stTabs [data-baseweb="tab"] { background-color: #262730; border-radius: 5px; color: white; padding: 10px 20px; }
#     .stTabs [aria-selected="true"] { background-color: #ff4b4b !important; color: white !important; }
# 
#     /* Table Styling */
#     [data-testid="stDataFrame"] { background-color: #262730 !important; }
#     </style>
# """, unsafe_allow_html=True)
# 
# # --- 3. THE SMART ENGINE ---
# @st.cache_data(show_spinner=False)
# def fetch_smart(path_or_url, file_type):
#     if path_or_url.startswith("http"):
#         url = path_or_url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/")
#     else:
#         safe_path = quote(path_or_url)
#         url = GITHUB_BASE + safe_path
# 
#     try:
#         r = requests.get(url)
#         if r.status_code == 200:
#             if file_type == 'json' or url.lower().endswith('.json'):
#                 text = r.content.decode('utf-8', errors='ignore')
#                 s, e = text.find('('), text.rfind(')')
#                 if s!=-1 and e!=-1: return True, json.loads(text[s+1:e]), url
#                 s, e = text.find('{'), text.rfind('}')
#                 if s!=-1 and e!=-1: return True, json.loads(text[s:e+1]), url
#                 return False, "JSON Clean Failed", url
# 
#             elif url.lower().endswith('.csv'):
#                 return True, pd.read_csv(BytesIO(r.content)), url
#             else:
#                 return True, pd.read_excel(BytesIO(r.content), engine='openpyxl'), url
# 
#         return False, f"HTTP {r.status_code}", url
# 
#     except Exception as e:
#         return False, str(e), url
# 
# def parse_match_events(json_data):
#     events = []
#     try:
#         try:
#             contestants = json_data['matchInfo']['contestant']
#             home_name, home_id = contestants[0]['name'], contestants[0]['id']
#             away_name = contestants[1]['name']
#         except: home_name, away_name, home_id = "Home", "Away", "Unknown"
# 
#         raw = json_data.get('liveData', {}).get('event', [])
#         if not raw: raw = json_data.get('event', [])
# 
#         for e in raw:
#             try:
#                 tid = e.get('typeId')
#                 events.append({
#                     "Type": tid,
#                     "Player": e.get('playerName', 'Unknown'),
#                     "Team": home_name if e.get('contestantId') == home_id else away_name,
#                     "Period": e.get('periodId'),
#                     "x": float(e.get('x', 0)),
#                     "y": float(e.get('y', 0)),
#                     "endX": float(next((q['value'] for q in e.get('qualifier', []) if q['qualifierId']==140), e.get('x', 0))),
#                     "endY": float(next((q['value'] for q in e.get('qualifier', []) if q['qualifierId']==141), e.get('y', 0))),
#                     "Outcome": "Successful" if e.get('outcome')==1 else "Unsuccessful",
#                     "IsKeyPass": any(q['qualifierId'] == 210 for q in e.get('qualifier', []))
#                 })
#             except: continue
#     except: return pd.DataFrame()
#     return pd.DataFrame(events)
# 
# # --- 4. THE INTERFACE ---
# with st.sidebar:
#     st.header("üß¨ FORENSICS UNIT")
#     st.caption("TACTICAL INTELLIGENCE DIVISION")
#     st.divider()
# 
#     app_mode = st.radio("üóÇÔ∏è ARCHIVES", ["CRIME SCENE", "INTELLIGENCE UNIT"])
# 
#     st.divider()
#     st.markdown("**SYSTEM METRICS**")
#     st.code(f"DATE: {datetime.now().strftime('%Y-%m-%d')}", language="bash")
#     st.code("SIGNAL: STRONG", language="bash")
#     st.code("CLEARANCE: LEVEL 5", language="bash")
# 
# if app_mode == "CRIME SCENE":
#     st.title("üß¨ FORENSICS xG")
#     st.markdown("**WHERE THE BEAUTIFUL GAME MEETS HARD EVIDENCE.**")
#     st.write("")
# 
#     st.markdown("##### SELECT SUSPECT:")
#     managers = list(CASE_DATABASE.keys())
#     tabs = st.tabs(managers)
# 
#     for i, manager in enumerate(managers):
#         with tabs[i]:
#             sub_t1, sub_t2 = st.tabs(["üìä STATISTICAL REPORTS", "‚öΩ MATCH TELEMETRY"])
# 
#             # === TAB A: STATS ===
#             with sub_t1:
#                 files = CASE_DATABASE[manager]["stats_files"]
# 
#                 options = list(files.keys()) + ["üîó Paste GitHub Link..."]
#                 selected_option = st.selectbox("SELECT EVIDENCE DATASET", options, key=f"s_sel_{i}")
# 
#                 target_path = ""
#                 if selected_option == "üîó Paste GitHub Link...":
#                     target_path = st.text_input("Paste Link Here", placeholder="https://github.com/...", key=f"s_link_{i}")
#                 else:
#                     target_path = files.get(selected_option, "")
# 
#                 if target_path:
#                     success, result, final_url = fetch_smart(target_path, 'excel')
# 
#                     if success:
#                         st.success(f"‚úÖ Loaded: {selected_option}")
#                         df = result
#                         df.columns = df.columns.astype(str).str.strip()
#                         num_cols = df.select_dtypes(include=np.number).columns.tolist()
#                         txt_cols = df.select_dtypes(include='object').columns.tolist()
# 
#                         if num_cols:
#                             c1, c2, c3 = st.columns(3)
#                             def_x = next((c for c in num_cols if 'xG' in c or 'Exp' in c), num_cols[0])
#                             def_y = next((c for c in num_cols if 'Gls' in c or 'Goal' in c), num_cols[1] if len(num_cols)>1 else num_cols[0])
#                             def_lbl = next((c for c in txt_cols if 'Player' in c or 'Squad' in c), txt_cols[0] if txt_cols else None)
# 
#                             x = c1.selectbox("X Axis", num_cols, index=num_cols.index(def_x), key=f"sx_{i}")
#                             y = c2.selectbox("Y Axis", num_cols, index=num_cols.index(def_y), key=f"sy_{i}")
#                             lbl = c3.selectbox("Label", txt_cols, index=txt_cols.index(def_lbl) if def_lbl else 0, key=f"sl_{i}")
# 
#                             st.subheader(f"{x} vs {y}")
#                             fig = px.scatter(df, x=x, y=y, text=lbl, template="plotly_dark")
#                             fig.update_traces(marker=dict(size=14, color='#ff4b4b', line=dict(width=1, color='white')), textposition='top center')
#                             fig.update_layout(height=600, paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(255,255,255,0.05)')
#                             st.plotly_chart(fig, use_container_width=True)
# 
#                             # --- FAST TOGGLE FOR RAW DATA ---
#                             st.divider()
#                             st.markdown("#### üìÇ EVIDENCE LOCKER")
#                             if st.checkbox("Show Raw Data Table", key=f"chk_{i}"):
#                                 st.dataframe(df, use_container_width=True)
#                         else: st.warning("No numeric columns found.")
#                     else: st.error(f"Connection Failed: {result}")
#                 else: st.info(f"No Statistical Reports available for {manager}.")
# 
#             # === TAB B: TELEMETRY ===
#             with sub_t2:
#                 files = CASE_DATABASE[manager]["json_files"]
#                 options = list(files.keys()) + ["üîó Paste GitHub Link..."]
#                 selected_option = st.selectbox("SELECT MATCH REPORT", options, key=f"j_sel_{i}")
# 
#                 target_path = ""
#                 if selected_option == "üîó Paste GitHub Link...":
#                     target_path = st.text_input("Paste Link Here", placeholder="https://github.com/...", key=f"j_link_{i}")
#                 else:
#                     target_path = files.get(selected_option, "")
# 
#                 if target_path:
#                     with st.spinner("Decrypting Ballistics Data..."):
#                         success, result, final_url = fetch_smart(target_path, 'json')
# 
#                     if success:
#                         st.success(f"‚úÖ Match Loaded")
#                         df = parse_match_events(result)
#                         if not df.empty:
#                             teams = df['Team'].unique()
#                             st.header(f"{teams[0]} vs {teams[1]}")
#                             c1, c2 = st.columns(2)
#                             team = c1.selectbox("Squad", teams, key=f"tm_{i}")
#                             players = sorted(df[df['Team']==team]['Player'].unique())
#                             players.insert(0, "All Players")
#                             player = c2.selectbox("Player", players, key=f"pl_{i}")
#                             plot_df = df[(df['Team']==team) & (df['Player']==player)] if player != "All Players" else df[df['Team']==team]
# 
#                             st.divider()
#                             modules = st.multiselect("ACTIVATE MODULES", ["Pass Map", "Heatmap", "Avg Positions"], default=["Pass Map"], key=f"mod_{i}")
# 
#                             if "Pass Map" in modules:
#                                 st.subheader("PASSING NETWORK")
#                                 passes = plot_df[plot_df['Type'] == 1]
#                                 if not passes.empty:
#                                     pitch = Pitch(pitch_type='opta', pitch_color='#0e1117', line_color='#444')
#                                     fig, ax = pitch.draw(figsize=(10, 7))
#                                     succ = passes[passes['Outcome'] == 'Successful']
#                                     fail = passes[passes['Outcome'] == 'Unsuccessful']
#                                     pitch.arrows(succ.x, succ.y, succ.endX, succ.endY, width=2, color='#00ff85', alpha=0.6, ax=ax)
#                                     pitch.arrows(fail.x, fail.y, fail.endX, fail.endY, width=2, color='#ff4b4b', alpha=0.6, ax=ax)
#                                     st.pyplot(fig)
#                                 else: st.warning("No Pass Data")
# 
#                             if "Heatmap" in modules:
#                                 st.subheader("THERMAL FOOTPRINT")
#                                 periods = sorted(plot_df['Period'].unique())
#                                 valid = [p for p in periods if p <= 5]
#                                 if not valid: valid = periods[:2]
#                                 cols = st.columns(len(valid))
#                                 for idx, p in enumerate(valid):
#                                     with cols[idx]:
#                                         st.write(f"**Period {p}**")
#                                         h = plot_df[plot_df['Period'] == p]
#                                         if len(h) > 5:
#                                             pitch = Pitch(pitch_type='opta', line_zorder=2, pitch_color='#0e1117', line_color='#444')
#                                             fig, ax = pitch.draw(figsize=(8, 6))
#                                             pitch.kdeplot(h.x, h.y, ax=ax, cmap='hot', fill=True, levels=100, alpha=0.7)
#                                             st.pyplot(fig)
#                     else: st.error(result)
#                 else: st.info(f"No Match Telemetry available for {manager}.")
# 
# elif app_mode == "INTELLIGENCE UNIT":
#     st.info("Access Denied.")

!pkill -f localtunnel
!streamlit run forensics_app.py & npx localtunnel --port 8501